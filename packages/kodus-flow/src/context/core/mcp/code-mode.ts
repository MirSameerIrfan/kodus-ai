import type { MCPRegistration, MCPToolReference } from '../interfaces.js';
import type { MCPRegistry } from './registry.js';

export interface ToolModuleDescriptor {
    providerId: string;
    toolName: string;
    filePath: string;
    registration: MCPRegistration;
    tool: MCPToolReference;
}

export interface CodeModeGenerationOptions {
    baseDir?: string;
    extension?: 'ts' | 'js';
    clientImportPath?: string;
    helperName?: string;
}

export const DEFAULT_CODE_MODE_DIR = 'servers';
export const DEFAULT_CLIENT_IMPORT = undefined;

const DEFAULT_HELPER = 'callMCPTool';

export function enumerateToolModules(
    registry: MCPRegistry,
    options: CodeModeGenerationOptions = {},
): ToolModuleDescriptor[] {
    const baseDir = options.baseDir ?? DEFAULT_CODE_MODE_DIR;
    const extension = options.extension ?? 'ts';

    const modules: ToolModuleDescriptor[] = [];
    for (const registration of registry.list()) {
        const providerSlug = slugify(registration.id || registration.title);
        for (const tool of registration.tools) {
            const toolSlug = slugify(tool.toolName);
            modules.push({
                providerId: providerSlug,
                toolName: toolSlug,
                filePath: `${baseDir}/${providerSlug}/${toolSlug}.${extension}`,
                registration,
                tool,
            });
        }
    }

    return modules;
}

export function renderToolModule(
    descriptor: ToolModuleDescriptor,
    options: CodeModeGenerationOptions = {},
): string {
    const helperName = options.helperName ?? DEFAULT_HELPER;
    const fnName = safeIdentifier(descriptor.tool.toolName);

    const header = options.clientImportPath
        ? `import { ${helperName} } from '${options.clientImportPath}';\n\n`
        : '';
    const helperCall = options.clientImportPath
        ? `${helperName}<TResult>`
        : `globalThis.__sandbox.${helperName}`;

    return `${header}/**
 * Auto-generated MCP tool module for ${descriptor.registration.id}/${descriptor.tool.toolName}.
 * Generated by Context-OS code mode scaffolding.
 */
export async function ${fnName}<TInput = Record<string, unknown>, TResult = unknown>(input: TInput): Promise<TResult> {
    return ${helperCall}<TResult>({
        mcpId: '${descriptor.registration.id}',
        toolName: '${descriptor.tool.toolName}',
        input,
    });
}
`;
}

export async function generateToolModuleMap(
    registry: MCPRegistry,
    options: CodeModeGenerationOptions = {},
): Promise<Record<string, string>> {
    const modules = enumerateToolModules(registry, options);
    const output: Record<string, string> = {};

    for (const module of modules) {
        output[module.filePath] = renderToolModule(module, options);
    }

    return output;
}

function slugify(value?: string): string {
    if (!value) {
        return 'unknown';
    }
    return (
        value
            .toLowerCase()
            .replace(/[^a-z0-9]+/g, '-')
            .replace(/^-+|-+$/g, '') || 'unknown'
    );
}

function safeIdentifier(value: string): string {
    const cleaned = value.replace(/[^a-zA-Z0-9_]/g, '_');
    const prefixed = /^[a-zA-Z_]/.test(cleaned) ? cleaned : `tool_${cleaned}`;
    return prefixed.replace(/__+/g, '_');
}
