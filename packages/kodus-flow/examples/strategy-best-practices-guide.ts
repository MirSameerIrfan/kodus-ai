/**
 * üéØ GUIA DEFINITIVO: Melhores Pr√°ticas para Camada Strategies
 *
 * Este guia consolida todas as melhores pr√°ticas para trabalhar
 * corretamente com a nova camada de strategies do Kodus Flow.
 */

import {
    StrategyExecutionContext,
    ExecutionResult,
} from '../src/engine/strategies/index.js';

// =============================================================================
// üìã PRINC√çPIOS FUNDAMENTAIS
// =============================================================================

/**
 * üéØ Princ√≠pios Orientadores
 */
export const StrategyPrinciples = {
    /**
     * 1. Separa√ß√£o Clara de Responsabilidades
     */
    separationOfConcerns: {
        rule: 'Cada estrat√©gia deve ter responsabilidade √∫nica e bem definida',
        react: 'Respons√°vel por: Pensar ‚Üí Agir ‚Üí Observar (iterativo)',
        rewoo: 'Respons√°vel por: Planejar ‚Üí Executar ‚Üí Sintetizar (estruturado)',
        context: 'Respons√°vel por: Gerenciar estado runtime e enriquecer dados',
    },

    /**
     * 2. Context First
     */
    contextFirst: {
        rule: 'Sempre enrique√ßa o context antes da execu√ß√£o',
        required: [
            'Agent identity e permissions',
            'Session state e history',
            'Runtime metrics e health',
            'Tool availability e validation',
            'Kernel state e memory',
        ],
        benefits: [
            'Execu√ß√µes mais inteligentes',
            'Melhores decis√µes de estrat√©gia',
            'Context-aware responses',
            'Debugging mais f√°cil',
        ],
    },

    /**
     * 3. Strategy Selection Intelligence
     */
    strategySelection: {
        rule: 'Escolha estrat√©gia baseada em dados, n√£o em opini√£o',
        criteria: {
            complexity: {
                low: 'ReAct (‚â§ 3)',
                medium: 'ReAct ou ReWoo (4-6)',
                high: 'ReWoo (‚â• 7)',
            },
            tools: {
                few: 'ReAct (‚â§ 5 tools)',
                many: 'ReWoo (‚â• 6 tools)',
            },
            history: {
                none: 'ReAct (exploratory)',
                rich: 'ReAct (contextual)',
                complex: 'ReWoo (structured)',
            },
        },
    },

    /**
     * 4. Error Handling Robustness
     */
    errorHandling: {
        rule: 'Trate erros graceful e forne√ßa recovery paths',
        strategies: [
            'Retry com estrat√©gia alternativa',
            'Fallback para estrat√©gia mais simples',
            'Partial results quando poss√≠vel',
            'Detailed error context para debugging',
        ],
    },
};

// =============================================================================
// üèóÔ∏è ARQUITETURA RECOMENDADA
// =============================================================================

/**
 * üìÅ Estrutura de Arquivos Recomendada
 */
export const RecommendedArchitecture = {
    structure: {
        'src/engine/strategies/': {
            'index.ts': 'Exports p√∫blicos e tipos',
            'strategy-interface.ts': 'Contratos base (BaseExecutionStrategy)',
            'react-strategy.ts': 'Implementa√ß√£o ReAct completa',
            'rewoo-strategy.ts': 'Implementa√ß√£o ReWoo completa',
            'strategy-factory.ts': 'Factory para cria√ß√£o de estrat√©gias',
            'shared-methods.ts': 'M√©todos comuns (LLM, Tools, Analysis)',
            'stop-conditions.ts': 'Condi√ß√µes de parada configur√°veis',
            'types.ts': 'Tipos TypeScript espec√≠ficos',
            'prompts/': {
                'react/': {
                    'system-prompt.ts': 'Prompt base ReAct',
                    'user-templates.ts': 'Templates parametriz√°veis',
                    'examples.ts': 'Exemplos de uso',
                    'validation.ts': 'Regras de valida√ß√£o',
                },
                'rewoo/': {
                    'planner-prompts.ts': 'Prompts de planejamento',
                    'executor-prompts.ts': 'Prompts de execu√ß√£o',
                    'organizer-prompts.ts': 'Prompts de s√≠ntese',
                    'examples.ts': 'Exemplos complexos',
                },
                'shared/': {
                    'context-formatters.ts': 'Formatadores de context',
                    'tool-descriptions.ts': 'Descri√ß√µes de ferramentas',
                    'validation-rules.ts': 'Regras de valida√ß√£o comuns',
                },
            },
        },
        'src/core/context/': {
            'strategy-context-manager.ts': 'Gerenciador de context espec√≠fico',
            'runtime-enricher.ts': 'Enriquecedor de dados runtime',
            'context-validators.ts': 'Validadores de context',
        },
    },

    benefits: [
        'üîç Localiza√ß√£o f√°cil de c√≥digo',
        'üîß Manutenibilidade clara',
        'üìä Separa√ß√£o de responsabilidades',
        'üöÄ Escalabilidade horizontal',
        'üë• Colabora√ß√£o em equipe',
    ],
};

// =============================================================================
// üéØ MELHORES PR√ÅTICAS POR COMPONENTE
// =============================================================================

/**
 * üìù Prompts: Como Organizar Corretamente
 */
export const PromptBestPractices = {
    /**
     * Estrutura de Prompt Base
     */
    baseStructure: {
        system: {
            required: ['Role definition', 'Process explanation', 'Constraints'],
            optional: ['Examples', 'Edge cases', 'Performance tips'],
            format: 'Clear, structured, actionable',
        },
        user: {
            required: ['Context', 'Task', 'Constraints'],
            optional: ['Examples', 'History', 'Preferences'],
            format: 'Conversational, specific, bounded',
        },
    },

    /**
     * Estrat√©gia de Parametriza√ß√£o
     */
    parametrization: {
        rules: [
            'Use placeholders para dados vari√°veis',
            'Valide par√¢metros obrigat√≥rios',
            'Forne√ßa defaults sensatos',
            'Documente formato esperado',
        ],
        examples: {
            bad: 'Execute a tarefa: {{task}}',
            good: 'Execute a tarefa: {{task}}\nContexto: {{context}}\nRestri√ß√µes: {{constraints}}',
        },
    },

    /**
     * Gest√£o de Vers√µes
     */
    versioning: {
        strategy: 'Semantic versioning por estrat√©gia',
        storage: 'Database com hist√≥rico de vers√µes',
        migration: 'Scripts para upgrade gradual',
        testing: 'Testes de regress√£o por vers√£o',
    },

    /**
     * Valida√ß√£o e Testes
     */
    validation: {
        structure: 'JSON Schema para validar formato',
        content: 'Regras de neg√≥cio espec√≠ficas',
        performance: 'Testes de token count e latency',
        accuracy: 'Testes de output quality',
    },
};

/**
 * üîß Context: Como Gerenciar Runtime
 */
export const ContextBestPractices = {
    /**
     * Enriquecimento Obrigat√≥rio
     */
    enrichment: {
        kernel: ['State', 'Memory usage', 'Active processes'],
        memory: ['Recent items', 'Categories', 'Access patterns'],
        session: ['Duration', 'Interactions', 'Metadata'],
        observability: ['Metrics', 'Traces', 'Health checks'],
    },

    /**
     * Valida√ß√£o de Context
     */
    validation: {
        required: ['Agent identity', 'Session info', 'Tool permissions'],
        optional: ['Runtime metrics', 'Historical data', 'Preferences'],
        types: 'TypeScript strict mode sempre',
        runtime: 'Valida√ß√£o em tempo de execu√ß√£o',
    },

    /**
     * Cache Strategy
     */
    caching: {
        levels: ['Memory', 'Redis', 'Database'],
        ttl: {
            kernel: '30s',
            memory: '5m',
            session: '1h',
            tools: '10m',
        },
        invalidation: 'Event-driven cache invalidation',
    },
};

/**
 * ‚öôÔ∏è Estrat√©gias: Como Implementar
 */
export const StrategyImplementationBestPractices = {
    /**
     * ReAct Strategy
     */
    react: {
        principles: [
            'Iterative thinking process',
            'Action validation before execution',
            'Observation-based learning',
            'Graceful degradation on errors',
        ],
        patterns: {
            thinking: 'Structured reasoning format',
            acting: 'Tool selection and parameter binding',
            observing: 'Result analysis and feedback',
            deciding: 'Stop condition evaluation',
        },
        antiPatterns: [
            'Infinite loops without proper stopping',
            'Tool execution without validation',
            'Ignoring observation results',
            'Hardcoded decision logic',
        ],
    },

    /**
     * ReWoo Strategy
     */
    rewoo: {
        principles: [
            'Planning-first approach',
            'Independent task decomposition',
            'Parallel execution when possible',
            'Structured result synthesis',
        ],
        patterns: {
            planning: 'Task decomposition and dependency analysis',
            executing: 'Independent task execution',
            organizing: 'Result aggregation and synthesis',
            validating: 'Consistency and completeness checks',
        },
        antiPatterns: [
            'Sequential execution of independent tasks',
            'Over-planning simple problems',
            'Ignoring task dependencies',
            'Incomplete result synthesis',
        ],
    },
};

/**
 * üß™ Testes: Estrat√©gia Completa
 */
export const TestingBestPractices = {
    /**
     * Pir√¢mide de Testes
     */
    pyramid: {
        unit: {
            scope: 'Individual functions and methods',
            coverage: '80%+ line coverage',
            mocks: 'External dependencies (LLM, Tools)',
            focus: 'Logic correctness',
        },
        integration: {
            scope: 'Strategy execution with real context',
            coverage: 'Key execution paths',
            mocks: 'Only external services',
            focus: 'End-to-end correctness',
        },
        e2e: {
            scope: 'Complete execution with real LLM',
            coverage: 'Critical user scenarios',
            mocks: 'None',
            focus: 'Real-world behavior',
        },
    },

    /**
     * Test Data Strategy
     */
    testData: {
        fixtures: 'Realistic but deterministic data',
        factories: 'Flexible test data generation',
        snapshots: 'Expected output validation',
        parameterization: 'Multiple scenarios per test',
    },

    /**
     * Performance Testing
     */
    performance: {
        benchmarks: 'Execution time, memory usage, token count',
        load: 'Concurrent strategy executions',
        stress: 'High complexity scenarios',
        monitoring: 'Resource usage patterns',
    },
};

// =============================================================================
// üöÄ PADR√ïES DE USO RECOMENDADOS
// =============================================================================

/**
 * üéØ Padr√µes de Execu√ß√£o por Cen√°rio
 */
export const UsagePatterns = {
    /**
     * Cen√°rio: Tarefa Simples
     */
    simpleTask: {
        strategy: 'react',
        config: {
            maxIterations: 5,
            maxToolCalls: 3,
            timeout: 30000,
        },
        context: 'minimal',
        monitoring: 'basic',
    },

    /**
     * Cen√°rio: Tarefa Complexa
     */
    complexTask: {
        strategy: 'rewoo',
        config: {
            maxIterations: 15,
            maxToolCalls: 25,
            timeout: 300000,
        },
        context: 'full',
        monitoring: 'detailed',
    },

    /**
     * Cen√°rio: Sistema Interativo
     */
    interactiveSystem: {
        strategy: 'react',
        config: {
            maxIterations: 10,
            maxToolCalls: 15,
            timeout: 120000,
            streaming: true,
        },
        context: 'session-aware',
        monitoring: 'real-time',
    },

    /**
     * Cen√°rio: Processamento em Lote
     */
    batchProcessing: {
        strategy: 'rewoo',
        config: {
            maxIterations: 20,
            maxToolCalls: 50,
            timeout: 600000,
            parallel: true,
        },
        context: 'optimized',
        monitoring: 'aggregated',
    },
};

/**
 * üîÑ Padr√µes de Transi√ß√£o
 */
export const TransitionPatterns = {
    /**
     * Migra√ß√£o Gradual
     */
    gradualMigration: {
        phase1: 'Paralelo com sistema antigo',
        phase2: 'Feature flags para novo sistema',
        phase3: 'A/B testing de estrat√©gias',
        phase4: 'Full migration com rollback plan',
    },

    /**
     * Rollback Strategy
     */
    rollback: {
        triggers: ['Error rate > 5%', 'Performance degradation > 20%'],
        process: 'Feature flag disable + monitoring',
        recovery: 'Automatic fallback to old system',
    },

    /**
     * Feature Flags
     */
    featureFlags: {
        strategy: 'strategy-selection-method',
        prompts: 'prompt-version-selection',
        context: 'context-enrichment-level',
        monitoring: 'metrics-collection-level',
    },
};

// =============================================================================
// üìä MONITORAMENTO E OBSERVABILIDADE
// =============================================================================

/**
 * üìà M√©tricas Essenciais
 */
export const EssentialMetrics = {
    /**
     * Performance Metrics
     */
    performance: {
        executionTime: 'Average, p95, p99',
        tokenEfficiency: 'Tokens per second',
        memoryUsage: 'Peak and average',
        throughput: 'Executions per minute',
    },

    /**
     * Quality Metrics
     */
    quality: {
        successRate: 'Successful executions %',
        errorRate: 'Error breakdown by type',
        accuracy: 'Output quality scores',
        userSatisfaction: 'User feedback scores',
    },

    /**
     * Strategy Metrics
     */
    strategy: {
        selectionAccuracy: 'Correct strategy selection %',
        completionRate: 'Tasks completed successfully %',
        iterationEfficiency: 'Average iterations per task',
        toolUtilization: 'Tools used per execution',
    },

    /**
     * Context Metrics
     */
    context: {
        enrichmentTime: 'Context enrichment latency',
        enrichmentSuccess: 'Successful enrichment %',
        cacheHitRate: 'Context cache efficiency',
        dataFreshness: 'Context data age',
    },
};

/**
 * üö® Alertas e Thresholds
 */
export const AlertsAndThresholds = {
    critical: {
        errorRate: '> 5%',
        executionTime: '> 300s',
        memoryUsage: '> 1GB',
    },

    warning: {
        successRate: '< 95%',
        cacheHitRate: '< 80%',
        tokenEfficiency: '< 50 tokens/s',
    },

    info: {
        strategySelection: 'Log all auto-selections',
        contextEnrichment: 'Log enrichment failures',
        performanceDegradation: 'Compare with baselines',
    },
};

// =============================================================================
// üõ†Ô∏è FERRAMENTAS DE DESENVOLVIMENTO
// =============================================================================

/**
 * üß∞ Development Tools
 */
export const DevelopmentTools = {
    /**
     * Local Development
     */
    local: {
        promptTester: 'Test prompts with mock LLM',
        strategyDebugger: 'Step-through execution',
        contextInspector: 'Inspect enriched context',
        performanceProfiler: 'Execution performance analysis',
    },

    /**
     * Testing Tools
     */
    testing: {
        strategyValidator: 'Validate strategy outputs',
        promptComparator: 'Compare prompt versions',
        contextSimulator: 'Simulate different contexts',
        loadGenerator: 'Generate realistic load',
    },

    /**
     * Production Tools
     */
    production: {
        strategySwitcher: 'Runtime strategy switching',
        promptUpdater: 'Zero-downtime prompt updates',
        contextMonitor: 'Real-time context health',
        performanceDashboard: 'Strategy performance metrics',
    },
};

// =============================================================================
// üìö CHECKLIST DE IMPLEMENTA√á√ÉO
// =============================================================================

/**
 * ‚úÖ Checklist Completo para Nova Implementa√ß√£o
 */
export const ImplementationChecklist = {
    /**
     * Antes de Implementar
     */
    preImplementation: [
        { task: 'Definir requirements claros', status: 'required' },
        { task: 'Escolher estrat√©gia apropriada', status: 'required' },
        { task: 'Designar arquitetura de context', status: 'required' },
        { task: 'Planejar estrat√©gia de testes', status: 'required' },
        { task: 'Configurar monitoring b√°sico', status: 'required' },
    ],

    /**
     * Durante Implementa√ß√£o
     */
    duringImplementation: [
        { task: 'Seguir princ√≠pios de separa√ß√£o', status: 'required' },
        { task: 'Implementar valida√ß√µes robustas', status: 'required' },
        { task: 'Adicionar logging detalhado', status: 'required' },
        { task: 'Escrever testes unit√°rios', status: 'required' },
        { task: 'Testar integra√ß√£o completa', status: 'required' },
    ],

    /**
     * Ap√≥s Implementa√ß√£o
     */
    postImplementation: [
        { task: 'Executar testes de performance', status: 'required' },
        { task: 'Configurar monitoring avan√ßado', status: 'required' },
        { task: 'Documentar uso e limita√ß√µes', status: 'required' },
        { task: 'Planejar estrat√©gia de deployment', status: 'required' },
        { task: 'Estabelecer processo de rollback', status: 'required' },
    ],

    /**
     * Em Produ√ß√£o
     */
    production: [
        { task: 'Monitorar m√©tricas essenciais', status: 'required' },
        { task: 'Configurar alertas autom√°ticos', status: 'required' },
        { task: 'Implementar A/B testing', status: 'recommended' },
        { task: 'Coletar feedback de usu√°rios', status: 'recommended' },
        { task: 'Otimizar performance bottlenecks', status: 'ongoing' },
    ],
};

// =============================================================================
// üéØ CONCLUS√ÉO E RECOMENDA√á√ïES FINAIS
// =============================================================================

/**
 * üèÜ Recomenda√ß√µes Finais
 */
export const FinalRecommendations = {
    /**
     * Comece Pequeno
     */
    startSmall: {
        advice: 'Implemente uma estrat√©gia por vez',
        benefits: 'Aprendizado gradual, riscos menores',
        approach: 'ReAct primeiro, depois ReWoo',
    },

    /**
     * Mantenha Simplicidade
     */
    keepSimple: {
        advice: 'N√£o over-engineer solu√ß√µes simples',
        principle: 'Complexidade deve corresponder ao problema',
        rule: 'Se ReAct resolve, n√£o use ReWoo',
    },

    /**
     * Monitore Sempre
     */
    monitorAlways: {
        advice: 'Logging e m√©tricas s√£o essenciais',
        practice: 'Log everything, measure everything',
        tools: 'Use observability desde o in√≠cio',
    },

    /**
     * Teste Extensivamente
     */
    testExtensively: {
        advice: 'Cobertura de testes alta √© obrigat√≥ria',
        types: 'Unit, Integration, E2E, Performance',
        automation: 'CI/CD com testes automatizados',
    },

    /**
     * Aprenda e Itere
     */
    learnAndIterate: {
        advice: 'Use dados para melhorar continuamente',
        practice: 'A/B testing, user feedback, metrics analysis',
        mindset: 'Always be improving',
    },
};

/**
 * üöÄ Pr√≥ximos Passos Recomendados
 */
export const NextSteps = [
    '1. Leia os exemplos de implementa√ß√£o',
    '2. Escolha uma estrat√©gia para come√ßar',
    '3. Implemente com testes abrangentes',
    '4. Configure monitoring b√°sico',
    '5. Deploy com feature flags',
    '6. Monitore e otimize continuamente',
];

export default {
    StrategyPrinciples,
    RecommendedArchitecture,
    PromptBestPractices,
    ContextBestPractices,
    StrategyImplementationBestPractices,
    TestingBestPractices,
    UsagePatterns,
    TransitionPatterns,
    EssentialMetrics,
    AlertsAndThresholds,
    DevelopmentTools,
    ImplementationChecklist,
    FinalRecommendations,
    NextSteps,
};
