[
    {
        "title": "PR must reference external issue or ticket",
        "rule": "PRs must reference at least one external issue or ticket from issue tracking systems (Jira, Linear, GitHub Issues, etc.) in the PR title or description. Follow these steps: (1) Check `pr_title` and `pr_description` context variables to extract ticket references. Look for patterns like \"PROJ-123\", \"ABC-456\", \"#789\", \"LIN-123\", or explicit mentions like \"Refs:\", \"Closes:\", \"Related to:\". (2) For each ticket reference found, use the appropriate MCP tool to validate: If reference matches Jira format (e.g., PROJ-123), use @mcp<jira|get_issue> tool with the issue key. If reference matches Linear format (e.g., LIN-123), use @mcp<linear|get_issue> tool with the issue identifier. If reference matches GitHub format (e.g., #123), use @mcp<github|get_issue> tool with the issue number. (3) Verify that the ticket exists, is accessible, and is in an appropriate state (not closed/resolved unless the PR is closing it). (4) If no valid ticket reference is found or tickets don't exist, create a suggestion requiring the PR author to add a valid ticket reference in the format appropriate for their issue tracking system.",
        "why_is_this_important": "External ticket references provide traceability, link code changes to business requirements, enable better project management, and help track the context and history of changes across multiple systems.",
        "severity": "Medium",
        "language": "",
        "uuid": "",
        "buckets": [
            "pr-hygiene",
            "maintainability"
        ],
        "scope": "pull-request"
    },
    {
        "title": "Bug-related PRs must reference Sentry issues",
        "rule": "If a PR has a \"bug\" tag in `pr_tags`, mentions bug fixes in `pr_title` or `pr_description`, or contains error-related keywords (error, bug, fix, crash, exception), it must reference a corresponding Sentry issue. Follow these steps: (1) Extract error messages, file paths, or error types from `pr_description` and `pr_title`. (2) Use @mcp<sentry|search_events> tool with a natural language query containing the error message or file path. Search for events from the past 30 days that match the error description. Include the issue ID in the query results. (3) If events are found, use @mcp<sentry|get_issue_details> tool with the issue ID from the search results to retrieve specific issue details including stack traces, affected users, and frequency. (4) If no events are found, use @mcp<sentry|search_issues> tool with keywords from the PR description to find related grouped issues. (5) Based on the Sentry tool results, create a specific suggestion showing the Sentry issue ID, URL, and any relevant error details that should be included in the PR description. The PR description must include the Sentry issue ID or URL.",
        "why_is_this_important": "Linking bug fixes to Sentry issues provides visibility into production errors, helps track error resolution, enables better debugging context, and ensures fixes address actual production issues rather than theoretical problems.",
        "severity": "High",
        "language": "",
        "uuid": "",
        "buckets": [
            "pr-hygiene",
            "error-handling",
            "observability-logging"
        ],
        "scope": "pull-request"
    },
    {
        "title": "New API routes must be documented in routes file",
        "rule": "When new API routes, endpoints, or routes are added to the codebase, they must be documented in the appropriate routes documentation file. Follow these steps: (1) Check `pr_files_diff` to identify route additions. Look for new route definitions in controllers, route files, or API definition files. Extract route paths, HTTP methods (GET, POST, PUT, DELETE), and endpoint names. (2) Use @mcp<kodus|kodus_get_repository_files> tool with file patterns like 'routes.json', 'openapi.yaml', 'swagger.json', 'api-docs.md', or '**/routes/**' to locate route documentation files in the repository. (3) For each documentation file found, use @mcp<kodus|kodus_get_repository_content> tool to retrieve the file content. (4) Verify documentation: Check if each new route identified in step 1 is documented with: HTTP method, full path, request parameters (query params, path params, body schema), response schema, and description. (5) If routes are missing from documentation, create a specific suggestion listing each undocumented route and requiring that it be added to the appropriate documentation file with all required fields.",
        "why_is_this_important": "Undocumented routes create confusion for API consumers, break API discovery tools, make integration difficult, and can lead to inconsistent API usage. Proper documentation ensures API discoverability and maintainability.",
        "severity": "High",
        "language": "",
        "uuid": "",
        "buckets": [
            "api-conventions",
            "docs-adrs",
            "maintainability"
        ],
        "scope": "pull-request"
    },
    {
        "title": "Error mentions in PR must reference Sentry issues",
        "rule": "If `pr_description` or `pr_title` mentions fixing an error, exception, crash, or production issue, it must reference a corresponding Sentry issue. Follow these steps: (1) Extract the exact error message, exception type, or error description from `pr_description` or `pr_title`. (2) Use @mcp<sentry|search_events> tool with a natural language query based on the extracted error message. Search for events from the past 30 days. Include file paths mentioned in the PR (from `pr_files_diff`) in the search query to find events where stack.filename matches the changed files. Include the issue ID in the query results. (3) Use @mcp<sentry|get_issue_details> tool with the issue ID found in the search events to retrieve specific issue details including error frequency, affected users, stack traces, and recent occurrences. (4) If you have relevant information from the Sentry tool results, create a specific suggestion for the situation showing: the Sentry issue ID, the issue URL, any problems encountered (error frequency, user impact), and require that this information be added to the PR description. The PR description must include the Sentry issue ID or URL.",
        "why_is_this_important": "Linking error fixes to Sentry issues provides production context, helps verify the fix addresses the actual production error, enables tracking of error resolution rates, and ensures fixes are based on real production data rather than assumptions.",
        "severity": "High",
        "language": "",
        "uuid": "",
        "buckets": [
            "error-handling",
            "observability-logging",
            "pr-hygiene"
        ],
        "scope": "pull-request"
    },
    {
        "title": "PRs must follow organizational description template",
        "rule": "PRs must follow the organizational PR description template defined in the repository. Follow these steps: (1) Use @mcp<kodus|kodus_get_repository_files> tool to locate PR template files. Search for common template locations: '.github/PULL_REQUEST_TEMPLATE.md', 'docs/pr-template.md', '.github/pull_request_template.md', or '**/*template*.md'. (2) Use @mcp<kodus|kodus_get_repository_content> tool to retrieve the template file content. Extract the required sections from the template (e.g., Motivation, Approach, Testing, Risk Assessment, Description, Checklist). (3) Compare `pr_description` against the template structure: Check if all required sections from the template are present in `pr_description`. Verify that each section has meaningful content, not just placeholder text. (4) If sections are missing or incomplete, create a specific suggestion listing which template sections are missing or incomplete and require that they be added to the PR description with appropriate content.",
        "why_is_this_important": "Consistent PR templates ensure all necessary context is provided, speed up code review, improve documentation quality, help reviewers understand changes quickly, and maintain organizational standards for change communication.",
        "severity": "Low",
        "language": "",
        "uuid": "",
        "buckets": [
            "pr-hygiene",
            "docs-adrs"
        ],
        "scope": "pull-request"
    },
    {
        "title": "Database schema changes must validate migrations",
        "rule": "When code changes involve database schema modifications, corresponding database migration files must be created and validated. Follow these steps: (1) Check `pr_files_diff` for database schema changes: Look for migration files (migrations/, db/migrations/, alembic/versions/, flyway/, liquibase/), schema definition files, or model files with database changes. Identify new tables, column additions/modifications, index changes, constraint modifications, or data migrations. (2) Verify migration files exist: For each schema change identified, check if a corresponding migration file exists in `pr_files_diff`. Migration files should follow naming conventions (timestamp_description.sql or version_description format). (3) Use database MCP tools to validate migrations: For PostgreSQL, use @mcp<postgres|validate_migration> tool with the migration file content to verify syntax, check for potential issues, and validate rollback scripts. For MySQL, use @mcp<mysql|validate_migration> tool. For generic database tools, use @mcp<database|validate_migration> tool. Use @mcp<database|check_schema> tool to verify the migration aligns with current schema state. (4) Verify migration completeness: Check that migrations include both 'up' and 'down' (rollback) scripts. Verify that migrations are idempotent and can be applied safely. (5) If migrations are missing or invalid, create a specific suggestion requiring migration files with details about what schema changes need migrations and what validation errors were found.",
        "why_is_this_important": "Database migrations without proper validation can cause production outages, data loss, deployment failures, and schema inconsistencies. Validated migrations ensure safe database changes, enable rollbacks, maintain schema version control, and prevent production database corruption.",
        "severity": "Critical",
        "language": "",
        "uuid": "",
        "buckets": [
            "database-query-performance",
            "migrations-backward-compat",
            "security-hardening"
        ],
        "scope": "pull-request"
    },
    {
        "title": "Changes must verify monitoring alerts configuration",
        "rule": "When code changes affect system behavior, performance, error rates, or introduce new features, corresponding monitoring alerts and dashboards should be verified or updated. Follow these steps: (1) Analyze `pr_files_diff` and `pr_description` to identify affected areas: new API endpoints, modified database queries, changed error handling, performance-critical code paths, or new features. (2) Extract service names, endpoint paths, metric names, or feature identifiers from the code changes. (3) Use monitoring MCP tools to verify alerts: For Datadog, use @mcp<datadog|get_alerts> tool with the service name or metric name to check if alerts exist for error rate, latency, or throughput related to the changed code. For New Relic, use @mcp<newrelic|get_alerts> tool with application name and alert policy names to verify coverage. For Prometheus, use @mcp<prometheus|get_rules> tool to check if alerting rules exist for metrics related to the changes. For CloudWatch (AWS), use @mcp<cloudwatch|get_alarms> tool with metric names and namespace to verify alarm configuration. (4) If no alerts are found for critical changes (new endpoints, error handling changes, performance modifications), create a specific suggestion requiring alert configuration with details about what metrics should be monitored (error rate, latency, throughput, etc.).",
        "why_is_this_important": "Missing or outdated monitoring alerts prevent early detection of production issues, delay incident response, make debugging difficult, and can lead to extended outages. Proper monitoring ensures visibility into system health and enables proactive issue detection.",
        "severity": "Medium",
        "language": "",
        "uuid": "",
        "buckets": [
            "observability-logging",
            "performance-efficiency",
            "maintainability"
        ],
        "scope": "pull-request"
    },
    {
        "title": "Dependency changes must be scanned for vulnerabilities",
        "rule": "When code changes include dependency updates (check `pr_files_diff` for package.json, requirements.txt, pom.xml, Gemfile, go.mod, Cargo.toml, or similar dependency files), the new dependencies must be scanned for known vulnerabilities. Follow these steps: (1) Identify which dependency files were modified in `pr_files_diff`. Extract the list of added or updated package names and versions. (2) Use @mcp<snyk|test_project> tool with the repository path and package manager type to scan for vulnerabilities in the updated dependencies. Alternatively, use @mcp<snyk|get_vulnerabilities> tool with specific package names and versions. (3) Review the vulnerability results: Check for high or critical severity vulnerabilities (CVSS score >= 7.0). Verify if vulnerabilities affect the specific versions being added/updated. (4) If vulnerabilities are found, create a specific suggestion showing: the vulnerable package name and version, the vulnerability CVE ID or Snyk ID, severity level, affected version range, and recommended fix (upgrade to safe version or alternative package). Require that high/critical vulnerabilities be addressed before merging. (5) If using OWASP Dependency Check, use @mcp<owasp|scan_dependencies> tool to perform additional security scanning and cross-reference results.",
        "why_is_this_important": "Vulnerable dependencies introduce security risks that can be exploited in production. Scanning dependencies ensures that known vulnerabilities are identified and addressed before code is merged, preventing security breaches and compliance issues.",
        "severity": "Critical",
        "language": "",
        "uuid": "",
        "buckets": [
            "security-hardening",
            "dependency-supply-chain"
        ],
        "scope": "pull-request"
    },
    {
        "title": "Security vulnerabilities must reference security scanning results",
        "rule": "If a PR addresses security vulnerabilities, fixes security issues, or modifies security-sensitive code (check `pr_tags` for 'security', `pr_files_diff` for security-related files, or `pr_description` for security keywords), it must reference results from security scanning tools. Follow these steps: (1) Identify security-related changes: Check if `pr_tags` contains 'security', if files in `pr_files_diff` are in security/ or contain authentication/authorization logic, or if `pr_description` mentions security fixes. (2) Use security scanning MCP tools: For Snyk, use @mcp<snyk|test_project> tool to scan the repository for vulnerabilities. For OWASP Dependency Check, use @mcp<owasp|scan_dependencies> tool to scan dependencies. For SonarQube security hotspots, use @mcp<sonarqube|get_hotspots> tool to check for security issues. (3) Extract vulnerability information: Get CVE IDs, severity levels, affected components, and remediation recommendations from the scan results. (4) Verify that `pr_description` references the security scan results: Check if it mentions the CVE ID, Snyk/OWASP issue ID, or provides a link to the security scan report. (5) If security fixes are present but no scan results are referenced, create a suggestion requiring the PR author to include security scan results or explain why scanning was not performed.",
        "why_is_this_important": "Security fixes must be traceable to specific vulnerabilities to ensure proper remediation, enable security audits, help track security debt, and demonstrate compliance with security policies.",
        "severity": "High",
        "language": "",
        "uuid": "",
        "buckets": [
            "security-hardening",
            "pr-hygiene"
        ],
        "scope": "pull-request"
    },
    {
        "title": "Jira tickets referenced in PR must be validated",
        "rule": "If a PR references a Jira ticket (check `pr_title` and `pr_description` for Jira ticket patterns like PROJ-123, ABC-456, or explicit 'Refs: PROJ-123'), the ticket must exist and be accessible. Follow these steps: (1) Extract Jira ticket keys from `pr_title` and `pr_description`. Look for patterns matching [A-Z]+-[0-9]+ format. (2) For each Jira ticket key found, use @mcp<jira|get_issue> tool with the issue key (e.g., 'PROJ-123') to retrieve ticket details. (3) Verify ticket information: Check that the ticket exists, is accessible, has a valid status, and matches the PR's purpose. If the PR is closing the ticket, verify the ticket is in a closable state. (4) Extract relevant ticket information: Get ticket title, description, status, assignee, and related information that should be reflected in the PR. (5) If ticket is not found or inaccessible, create a suggestion requiring a valid Jira ticket reference. If ticket exists but status/details don't match PR purpose, create a suggestion to update the ticket or clarify the relationship. (6) Ensure `pr_description` includes the Jira ticket key in a clear format like 'Refs: PROJ-123' or 'Closes: PROJ-123'.",
        "why_is_this_important": "Valid Jira ticket references ensure traceability between code changes and business requirements, enable proper project management, help track work completion, and maintain alignment between development and project tracking systems.",
        "severity": "Medium",
        "language": "",
        "uuid": "",
        "buckets": [
            "pr-hygiene",
            "maintainability"
        ],
        "scope": "pull-request"
    },
    {
        "title": "Linear issues referenced in PR must be validated",
        "rule": "If a PR references a Linear issue (check `pr_title` and `pr_description` for Linear issue patterns like LIN-123, ABC-456, or explicit 'Refs: LIN-123'), the issue must exist and be accessible. Follow these steps: (1) Extract Linear issue identifiers from `pr_title` and `pr_description`. Look for patterns matching Linear issue format or explicit mentions. (2) For each Linear issue identifier found, use @mcp<linear|get_issue> tool with the issue identifier to retrieve issue details. (3) Verify issue information: Check that the issue exists, is accessible, has a valid state, and matches the PR's purpose. If the PR is completing the issue, verify the issue is in a completable state. (4) Extract relevant issue information: Get issue title, description, state, assignee, and related cycle/project information that should be reflected in the PR. (5) If issue is not found or inaccessible, create a suggestion requiring a valid Linear issue reference. If issue exists but state/details don't match PR purpose, create a suggestion to update the issue or clarify the relationship. (6) Ensure `pr_description` includes the Linear issue identifier in a clear format like 'Refs: LIN-123' or 'Closes: LIN-123'.",
        "why_is_this_important": "Valid Linear issue references ensure traceability between code changes and product requirements, enable proper project tracking, help teams understand context, and maintain alignment between development and product management.",
        "severity": "Medium",
        "language": "",
        "uuid": "",
        "buckets": [
            "pr-hygiene",
            "maintainability"
        ],
        "scope": "pull-request"
    },
    {
        "title": "Performance changes must verify monitoring metrics",
        "rule": "When code changes affect performance (check `pr_description` for performance keywords, `pr_files_diff` for database queries, API endpoints, or performance-critical code), corresponding monitoring metrics should be verified. Follow these steps: (1) Identify performance-related changes: Analyze `pr_files_diff` for database query modifications, new API endpoints, caching changes, or algorithm optimizations. Check `pr_description` for mentions of performance improvements or optimizations. (2) Extract metric identifiers: Identify service names, endpoint paths, database table names, or function names that should have corresponding metrics. (3) Use monitoring MCP tools to verify metrics exist: For Datadog, use @mcp<datadog|get_metrics> tool with service name and metric name patterns (e.g., 'api.request.duration', 'db.query.time') to check if metrics are being collected. For Prometheus, use @mcp<prometheus|query> tool with PromQL queries to verify metrics exist (e.g., 'http_request_duration_seconds', 'database_query_duration'). For CloudWatch, use @mcp<cloudwatch|get_metrics> tool with namespace and metric name to verify metric collection. (4) If performance-critical changes don't have corresponding metrics, create a suggestion requiring metric instrumentation with specific metric names that should be added (latency, throughput, error rate, etc.).",
        "why_is_this_important": "Performance changes without monitoring metrics make it impossible to measure the impact of optimizations, detect performance regressions, or validate that improvements achieved their goals. Proper metrics enable data-driven performance optimization.",
        "severity": "High",
        "language": "",
        "uuid": "",
        "buckets": [
            "performance-efficiency",
            "observability-logging"
        ],
        "scope": "pull-request"
    },
    {
        "title": "Production logs must be checked for error patterns",
        "rule": "When code changes modify error handling, logging, or exception handling (check `pr_files_diff` for error handling code, logging statements, or exception catches), production logs should be checked for related error patterns. Follow these steps: (1) Analyze `pr_files_diff` to identify error handling changes: Look for new exception types, error messages, logging statements, or error handling logic. Extract error message patterns, exception class names, or log message formats. (2) Extract service names, function names, or file paths from the code changes to identify where errors might occur. (3) Use logging MCP tools to search production logs: For Datadog, use @mcp<datadog|get_logs> tool with the service name and error message patterns to search for recent occurrences of similar errors in production logs. Search for logs from the past 7 days. (4) Analyze log results: Check if the error patterns being modified are actually occurring in production. Verify error frequency, affected users, and error context. (5) If production logs show related errors but the PR doesn't reference them, create a suggestion requiring the PR author to reference the production error patterns found in logs and explain how the changes address those errors.",
        "why_is_this_important": "Checking production logs ensures error handling changes address real production issues, helps validate that fixes target actual problems, enables better error context understanding, and prevents fixing theoretical errors while real issues persist.",
        "severity": "Medium",
        "language": "",
        "uuid": "",
        "buckets": [
            "error-handling",
            "observability-logging"
        ],
        "scope": "pull-request"
    },
    {
        "title": "Performance changes must analyze Sentry traces",
        "rule": "When code changes affect performance-critical paths (check `pr_description` for performance keywords, `pr_files_diff` for database queries, API endpoints, or performance optimizations), Sentry performance traces should be analyzed. Follow these steps: (1) Identify performance-related changes: Check `pr_files_diff` for database query modifications, new API endpoints, caching changes, algorithm optimizations, or async/await patterns. Check `pr_description` for mentions of performance improvements, latency reduction, or optimization. (2) Extract function names, endpoint paths, or operation names that should have performance traces. (3) Use Sentry trace analysis: Use @mcp<sentry|get_trace_details> tool with transaction names or operation names to retrieve performance traces. Search for traces related to the modified code paths. Analyze trace duration, span breakdown, and performance bottlenecks. (4) Verify performance impact: Check if the changes improve or maintain performance based on trace data. Identify any performance regressions or improvements. (5) If performance-critical changes don't have corresponding trace analysis, create a suggestion requiring trace analysis with specific transaction names or operations that should be monitored, and require that performance metrics be included in the PR description.",
        "why_is_this_important": "Analyzing Sentry traces provides real production performance data, helps validate performance optimizations, identifies performance bottlenecks, and ensures changes don't introduce performance regressions.",
        "severity": "High",
        "language": "",
        "uuid": "",
        "buckets": [
            "performance-efficiency",
            "observability-logging"
        ],
        "scope": "pull-request"
    },
    {
        "title": "Test coverage must meet minimum threshold",
        "rule": "When code changes add new features or modify existing functionality (check `pr_files_diff` for new functions, classes, or modified logic), test coverage should be verified to meet minimum thresholds. Follow these steps: (1) Identify code changes: Analyze `pr_files_diff` to identify new functions, classes, methods, or modified logic that should have test coverage. Extract file paths and function/class names. (2) Use coverage MCP tools: For SonarQube, use @mcp<sonarqube|get_coverage> tool with the file path or component name to retrieve current test coverage metrics. Check line coverage, branch coverage, and function coverage percentages. (3) Verify coverage thresholds: Check if the modified or new code meets minimum coverage thresholds (typically 80% line coverage, 70% branch coverage). Verify that new code has corresponding test files. (4) If coverage is below thresholds or new code lacks tests, create a specific suggestion requiring test coverage with details about which functions/files need tests and what coverage percentage should be achieved. Require that test files be added or updated before merging.",
        "why_is_this_important": "Adequate test coverage ensures code reliability, catches regressions early, enables safe refactoring, and maintains code quality standards. Low coverage increases the risk of bugs reaching production.",
        "severity": "High",
        "language": "",
        "uuid": "",
        "buckets": [
            "testing-quality",
            "maintainability"
        ],
        "scope": "pull-request"
    },
    {
        "title": "Dependency licenses must be validated",
        "rule": "When code changes include new dependencies (check `pr_files_diff` for package.json, requirements.txt, pom.xml, Gemfile, go.mod, Cargo.toml, or similar dependency files), dependency licenses must be validated for compliance. Follow these steps: (1) Identify new dependencies: Check `pr_files_diff` for dependency file modifications. Extract the list of newly added package names and versions. (2) Use license validation MCP tools: Use @mcp<snyk|get_licenses> tool with the package names to retrieve license information for each dependency. Check license types (MIT, Apache, GPL, proprietary, etc.) and license compatibility. (3) Verify license compliance: Check if licenses are compatible with your project's license policy. Identify any GPL, AGPL, or other copyleft licenses that might require special handling. Verify that proprietary licenses are acceptable. (4) If dependencies have incompatible or problematic licenses, create a specific suggestion listing each dependency with its license type, explaining why it's problematic, and requiring either: replacement with a compatible alternative, or documentation of why the license is acceptable with legal approval.",
        "why_is_this_important": "License compliance prevents legal issues, ensures compatibility with project licensing, avoids copyleft license contamination, and maintains intellectual property protection. Non-compliant licenses can force open-sourcing of proprietary code.",
        "severity": "Critical",
        "language": "",
        "uuid": "",
        "buckets": [
            "security-hardening",
            "dependency-supply-chain"
        ],
        "scope": "pull-request"
    },
    {
        "title": "Code quality metrics must meet SonarQube standards",
        "rule": "When code changes are made (check `pr_files_diff` for any code modifications), code quality metrics should be verified against SonarQube standards. Follow these steps: (1) Identify modified files: Extract file paths from `pr_files_diff` that contain code changes. (2) Use SonarQube quality metrics: Use @mcp<sonarqube|get_measures> tool with the file path or component name to retrieve quality metrics including: code smells, bugs, vulnerabilities, technical debt ratio, maintainability rating, reliability rating, and security rating. (3) Use @mcp<sonarqube|get_issues> tool to retrieve specific quality issues for the modified files, including code smells, bugs, and vulnerabilities. (4) Verify quality standards: Check that code smells are within acceptable limits, no critical bugs exist, no high-severity vulnerabilities are introduced, and maintainability rating is acceptable (A or B rating). (5) If quality metrics don't meet standards, create a specific suggestion listing each quality issue found (code smells, bugs, vulnerabilities) with their severity and location, and require that they be addressed before merging.",
        "why_is_this_important": "Maintaining code quality standards ensures maintainable code, reduces technical debt, prevents bugs and vulnerabilities, and maintains consistent code quality across the codebase. Poor quality metrics indicate code that will be difficult to maintain.",
        "severity": "Medium",
        "language": "",
        "uuid": "",
        "buckets": [
            "testing-quality",
            "maintainability"
        ],
        "scope": "pull-request"
    },
    {
        "title": "Monitoring dashboards must be updated for new features",
        "rule": "When code changes introduce new features, endpoints, or services (check `pr_files_diff` for new API endpoints, service files, or feature implementations), corresponding monitoring dashboards should be created or updated. Follow these steps: (1) Identify new features: Analyze `pr_files_diff` to identify new API endpoints, service classes, feature modules, or functionality. Extract service names, endpoint paths, feature identifiers, or component names. (2) Use dashboard MCP tools: For Datadog, use @mcp<datadog|get_dashboards> tool with service name or feature identifier to check if dashboards exist for the new feature. Search for dashboards containing relevant metrics (error rate, latency, throughput, user activity). (3) Verify dashboard coverage: Check if dashboards include metrics for the new feature: error rates, request latency, throughput, success rates, user engagement metrics. Verify that dashboards are properly configured and accessible. (4) If dashboards are missing or incomplete for new features, create a specific suggestion requiring dashboard creation or update with details about which metrics should be monitored (error rate, latency, throughput, etc.) and which dashboards need to be created or updated.",
        "why_is_this_important": "Monitoring dashboards provide visibility into feature health, enable early detection of issues, help track feature adoption and performance, and support data-driven decision making. Missing dashboards make it impossible to monitor new features.",
        "severity": "Medium",
        "language": "",
        "uuid": "",
        "buckets": [
            "observability-logging",
            "maintainability"
        ],
        "scope": "pull-request"
    },
    {
        "title": "Active incidents must be checked before deployment",
        "rule": "When a PR is ready to merge and deploy (check `pr_description` for deployment keywords, merge status, or production readiness), active incidents should be checked to avoid deploying during ongoing issues. Follow these steps: (1) Identify deployment readiness: Check `pr_description` for keywords like 'ready to deploy', 'merge', 'production', or deployment status. (2) Use incident MCP tools: For Datadog, use @mcp<datadog|get_incidents> tool to check for active incidents in the affected services or systems. Check incident severity, status (open, investigating, resolved), and affected services. (3) Verify incident status: Check if there are any active incidents (status: open or investigating) that might be affected by the deployment or that should be resolved before deploying. Verify incident severity and impact. (4) If active incidents exist that could be affected by the deployment, create a suggestion requiring that the incident be resolved or acknowledged before deployment, or that deployment be delayed until the incident is resolved. Include incident details (ID, severity, affected services) in the suggestion.",
        "why_is_this_important": "Deploying during active incidents can worsen the situation, make debugging harder, complicate rollback decisions, and increase incident duration. Checking incidents before deployment prevents compounding problems.",
        "severity": "High",
        "language": "",
        "uuid": "",
        "buckets": [
            "ci-cd-build-hygiene",
            "observability-logging"
        ],
        "scope": "pull-request"
    },
    {
        "title": "Jira project context must be validated",
        "rule": "If a PR references a Jira ticket (check `pr_title` and `pr_description` for Jira ticket patterns like PROJ-123), the Jira project context should be validated. Follow these steps: (1) Extract Jira ticket keys from `pr_title` and `pr_description`. Look for patterns matching [A-Z]+-[0-9]+ format. Extract the project key (e.g., 'PROJ' from 'PROJ-123'). (2) Use Jira project MCP tools: Use @mcp<jira|get_project> tool with the project key to retrieve project information including project name, key, description, and project type. (3) Verify project context: Check that the project is active, accessible, and relevant to the codebase. Verify that the project type matches the PR's purpose (software development project, not a support or documentation project). (4) If multiple tickets from different projects are referenced, verify that all projects are relevant and accessible. (5) If project context doesn't match or project is inaccessible, create a suggestion requiring valid project references or explaining project relevance. Ensure `pr_description` includes project context when multiple projects are involved.",
        "why_is_this_important": "Validating Jira project context ensures tickets are from the correct project, prevents confusion from wrong project references, enables proper project tracking, and maintains alignment between code changes and project management.",
        "severity": "Low",
        "language": "",
        "uuid": "",
        "buckets": [
            "pr-hygiene",
            "maintainability"
        ],
        "scope": "pull-request"
    },
    {
        "title": "Linear project and cycle context must be validated",
        "rule": "If a PR references a Linear issue (check `pr_title` and `pr_description` for Linear issue patterns), the Linear project and cycle context should be validated. Follow these steps: (1) Extract Linear issue identifiers from `pr_title` and `pr_description`. (2) Use Linear context MCP tools: Use @mcp<linear|get_issue> tool to get the issue details and extract project and cycle information. Use @mcp<linear|get_project> tool with the project identifier to retrieve project information including project name, description, and status. Use @mcp<linear|get_cycle> tool with the cycle identifier to retrieve cycle information including cycle name, start date, end date, and status. (3) Verify project and cycle context: Check that the project is active and relevant to the codebase. Verify that the cycle is current or appropriate for the work being done. Check that the issue's project and cycle align with the PR's purpose. (4) If project or cycle context doesn't match or is inaccessible, create a suggestion requiring valid project/cycle references or explaining context relevance. Ensure `pr_description` includes project and cycle information when relevant.",
        "why_is_this_important": "Validating Linear project and cycle context ensures issues are from the correct project and cycle, enables proper sprint planning, helps track work completion, and maintains alignment between code changes and product management cycles.",
        "severity": "Low",
        "language": "",
        "uuid": "",
        "buckets": [
            "pr-hygiene",
            "maintainability"
        ],
        "scope": "pull-request"
    },
    {
        "title": "Console.log statements must not be committed in production code",
        "rule": "The `fileDiff` must not contain `console.log`, `console.debug`, `console.info`, `print()`, or similar debugging statements in files that are not test files. Follow these steps: (1) Check the `filePath` context variable to determine if the file is a test file. Test files typically have patterns like '.test.', '.spec.', '/test/', '/spec/', '__tests__', or end with 'Test' or 'Spec'. (2) Analyze the `fileDiff` to identify any added lines containing `console.log`, `console.debug`, `console.info`, `print()`, `System.out.println`, or similar debugging statements. Look for lines starting with '+' that contain these patterns. (3) Use code quality MCP tools to verify: For SonarQube, use @mcp<sonarqube|get_issues> tool with the file path to check if there are code quality issues related to console.log statements or logging anti-patterns. Verify that code quality standards flag console.log usage in production code. (4) If debugging statements are found in non-test files, create a specific suggestion listing each occurrence with the line number and requiring that debugging statements be removed or replaced with proper logging using the application's logging framework (e.g., logger.debug(), logger.info()). (5) If debugging statements are in test files, they are acceptable and no action is needed.",
        "why_is_this_important": "Console.log statements in production code clutter logs, expose sensitive information, impact performance, and violate logging best practices. Production code should use proper logging frameworks with appropriate log levels.",
        "severity": "Medium",
        "language": "",
        "uuid": "",
        "buckets": [
            "style-conventions",
            "observability-logging"
        ],
        "scope": "file"
    },
    {
        "title": "Hardcoded secrets must not be committed",
        "rule": "The `fileDiff` must not contain hardcoded secrets, API keys, passwords, tokens, or sensitive credentials. Follow these steps: (1) Analyze the `fileDiff` to identify any added lines containing potential secrets. Look for patterns like: API keys (patterns like 'api_key', 'apikey', 'secret', 'token', 'password', 'pwd', 'passwd'), hardcoded values that look like secrets (long random strings, base64 encoded strings, JWT tokens), database connection strings with credentials, AWS access keys, or OAuth tokens. (2) Check for common secret patterns: Look for lines starting with '+' that contain assignments like 'password =', 'apiKey =', 'secret =', 'token =', or similar patterns followed by hardcoded values. (3) Use security scanning MCP tools to verify: For SonarQube, use @mcp<sonarqube|get_hotspots> tool with the file path to check for security hotspots related to hardcoded secrets. For Snyk, use @mcp<snyk|test_project> tool to scan for exposed secrets or credentials. Cross-reference the fileDiff analysis with security scan results. (4) Verify if values are actual secrets or placeholders: Check if values are clearly placeholders (e.g., 'YOUR_API_KEY', 'placeholder', 'example.com') which are acceptable. (5) If actual secrets are found, create a critical suggestion requiring immediate removal of the secret, explanation of how to use environment variables or secret management systems instead, and verification that the secret has been rotated if it was exposed.",
        "why_is_this_important": "Hardcoded secrets in code create severe security vulnerabilities, expose credentials in version control, enable unauthorized access, violate security best practices, and can lead to data breaches. Secrets must be stored in secure secret management systems.",
        "severity": "Critical",
        "language": "",
        "uuid": "",
        "buckets": [
            "security-hardening"
        ],
        "scope": "file"
    },
    {
        "title": "TODO and FIXME comments must reference tickets",
        "rule": "The `fileDiff` must not contain TODO or FIXME comments without ticket references. Follow these steps: (1) Analyze the `fileDiff` to identify any added lines containing TODO or FIXME comments. Look for patterns like 'TODO:', 'FIXME:', 'HACK:', 'XXX:', or similar technical debt markers. (2) Check if TODO/FIXME comments include ticket references: Verify that each TODO/FIXME comment includes a reference to an issue tracking system (Jira ticket like PROJ-123, Linear issue like LIN-123, GitHub issue like #123, or explicit ticket ID). (3) If TODO/FIXME comments are found without ticket references, create a suggestion requiring that each TODO/FIXME comment include a ticket reference in format like 'TODO(PROJ-123): description' or 'FIXME: description (Refs: LIN-456)'. (4) If TODO/FIXME comments have ticket references, verify they are valid using appropriate MCP tools (@mcp<jira|get_issue>, @mcp<linear|get_issue>, @mcp<github|get_issue>) to ensure tickets exist.",
        "why_is_this_important": "TODO and FIXME comments without ticket references create orphaned technical debt, make it impossible to track and prioritize fixes, lead to forgotten issues, and violate code maintenance best practices. Ticket references enable proper tracking and prioritization.",
        "severity": "Low",
        "language": "",
        "uuid": "",
        "buckets": [
            "maintainability",
            "style-conventions"
        ],
        "scope": "file"
    },
    {
        "title": "Architectural changes must have ADR documentation",
        "rule": "When code changes involve architectural decisions, significant design changes, or technology choices (check `pr_files_diff` for new frameworks, libraries, patterns, infrastructure changes, or major refactorings), an Architecture Decision Record (ADR) must be created or referenced. Follow these steps: (1) Analyze `pr_files_diff` and `pr_description` to identify architectural changes: Look for new framework or library introductions, major pattern changes (e.g., switching from REST to GraphQL, adding microservices, changing database, introducing caching layer), infrastructure changes (new services, message queues, event systems), or significant refactorings that change system architecture. Check `pr_description` for keywords like 'architecture', 'design', 'pattern', 'framework', 'infrastructure', 'refactor', or 'migration'. (2) Use repository MCP tools to locate ADR directory: Use @mcp<kodus|kodus_get_repository_files> tool to search for ADR directories. Common locations include 'docs/adr/', 'docs/architecture/', 'adr/', 'docs/decisions/', or 'architecture/decisions/'. Look for files matching ADR naming patterns like 'ADR-*.md', '*-adr.md', or numbered formats like '0001-*.md'. (3) For each architectural change identified, use @mcp<kodus|kodus_get_repository_content> tool to check if an ADR exists that documents this decision. Search ADR files for keywords related to the architectural change (framework name, pattern name, technology name). (4) Verify ADR completeness: If an ADR exists, verify it includes: context (why the decision is needed), decision (what was decided), consequences (pros and cons, impact), and status (proposed, accepted, deprecated). (5) If architectural changes are detected but no ADR exists or is referenced, create a specific suggestion requiring an ADR to be created with details about what architectural decision needs to be documented and where it should be located. The `pr_description` must reference the ADR number or include a link to the ADR file.",
        "why_is_this_important": "ADRs document architectural decisions, provide context for future developers, enable better understanding of system evolution, prevent repeated discussions, and maintain architectural knowledge over time. Missing ADRs lead to architectural drift and make it difficult to understand why certain decisions were made.",
        "severity": "Medium",
        "language": "",
        "uuid": "",
        "buckets": [
            "docs-adrs",
            "maintainability"
        ],
        "scope": "pull-request"
    }
]
