[
    {
        "title": "PR deve referenciar issue ou ticket externo",
        "rule": "PRs devem referenciar pelo menos uma issue ou ticket externo de sistemas de rastreamento de issues (Jira, Linear, GitHub Issues, etc.) no título ou descrição do PR. Siga estes passos: (1) Verifique as variáveis de contexto `pr_title` e `pr_description` para extrair referências de tickets. Procure por padrões como \"PROJ-123\", \"ABC-456\", \"#789\", \"LIN-123\", ou menções explícitas como \"Refs:\", \"Closes:\", \"Related to:\". (2) Para cada referência de ticket encontrada, use a ferramenta MCP apropriada para validar: Se a referência corresponde ao formato Jira (ex: PROJ-123), use a ferramenta @mcp<jira|get_issue> com a chave da issue. Se a referência corresponde ao formato Linear (ex: LIN-123), use a ferramenta @mcp<linear|get_issue> com o identificador da issue. Se a referência corresponde ao formato GitHub (ex: #123), use a ferramenta @mcp<github|get_issue> com o número da issue. (3) Verifique que o ticket existe, está acessível e está em um estado apropriado (não fechado/resolvido a menos que o PR esteja fechando-o). (4) Se nenhuma referência de ticket válida for encontrada ou os tickets não existirem, crie uma sugestão exigindo que o autor do PR adicione uma referência de ticket válida no formato apropriado para seu sistema de rastreamento de issues.",
        "why_is_this_important": "Referências de tickets externos fornecem rastreabilidade, vinculam mudanças de código a requisitos de negócio, permitem melhor gerenciamento de projetos e ajudam a rastrear o contexto e histórico de mudanças em múltiplos sistemas.",
        "severity": "Medium",
        "language": "",
        "uuid": "",
        "buckets": [
            "pr-hygiene",
            "maintainability"
        ],
        "scope": "pull-request"
    },
    {
        "title": "PRs relacionados a bugs devem referenciar issues do Sentry",
        "rule": "Se um PR tem a tag \"bug\" em `pr_tags`, menciona correções de bugs em `pr_title` ou `pr_description`, ou contém palavras-chave relacionadas a erros (error, bug, fix, crash, exception), ele deve referenciar uma issue correspondente do Sentry. Siga estes passos: (1) Extraia mensagens de erro, caminhos de arquivos ou tipos de erro de `pr_description` e `pr_title`. (2) Use a ferramenta @mcp<sentry|search_events> com uma consulta em linguagem natural contendo a mensagem de erro ou caminho do arquivo. Busque eventos dos últimos 30 dias que correspondam à descrição do erro. Inclua o ID da issue nos resultados da consulta. (3) Se eventos forem encontrados, use a ferramenta @mcp<sentry|get_issue_details> com o ID da issue dos resultados da busca para recuperar detalhes específicos da issue incluindo stack traces, usuários afetados e frequência. (4) Se nenhum evento for encontrado, use a ferramenta @mcp<sentry|search_issues> com palavras-chave da descrição do PR para encontrar issues agrupadas relacionadas. (5) Com base nos resultados das ferramentas do Sentry, crie uma sugestão específica mostrando o ID da issue do Sentry, URL e quaisquer detalhes de erro relevantes que devem ser incluídos na descrição do PR. A descrição do PR deve incluir o ID da issue do Sentry ou URL.",
        "why_is_this_important": "Vincular correções de bugs a issues do Sentry fornece visibilidade sobre erros de produção, ajuda a rastrear resolução de erros, permite melhor contexto de depuração e garante que as correções abordem problemas reais de produção em vez de problemas teóricos.",
        "severity": "High",
        "language": "",
        "uuid": "",
        "buckets": [
            "pr-hygiene",
            "error-handling",
            "observability-logging"
        ],
        "scope": "pull-request"
    },
    {
        "title": "Novas rotas de API devem ser documentadas em arquivo de rotas",
        "rule": "Quando novas rotas de API, endpoints ou rotas são adicionadas ao código, elas devem ser documentadas no arquivo de documentação de rotas apropriado. Siga estes passos: (1) Verifique `pr_files_diff` para identificar adições de rotas. Procure por novas definições de rotas em controladores, arquivos de rotas ou arquivos de definição de API. Extraia caminhos de rotas, métodos HTTP (GET, POST, PUT, DELETE) e nomes de endpoints. (2) Use a ferramenta @mcp<kodus|kodus_get_repository_files> com padrões de arquivo como 'routes.json', 'openapi.yaml', 'swagger.json', 'api-docs.md', ou '**/routes/**' para localizar arquivos de documentação de rotas no repositório. (3) Para cada arquivo de documentação encontrado, use a ferramenta @mcp<kodus|kodus_get_repository_content> para recuperar o conteúdo do arquivo. (4) Verifique a documentação: Verifique se cada nova rota identificada no passo 1 está documentada com: método HTTP, caminho completo, parâmetros de requisição (query params, path params, schema do body), schema de resposta e descrição. (5) Se rotas estiverem faltando na documentação, crie uma sugestão específica listando cada rota não documentada e exigindo que ela seja adicionada ao arquivo de documentação apropriado com todos os campos necessários.",
        "why_is_this_important": "Rotas não documentadas criam confusão para consumidores de API, quebram ferramentas de descoberta de API, dificultam a integração e podem levar a uso inconsistente de API. Documentação adequada garante descoberta e manutenibilidade da API.",
        "severity": "High",
        "language": "",
        "uuid": "",
        "buckets": [
            "api-conventions",
            "docs-adrs",
            "maintainability"
        ],
        "scope": "pull-request"
    },
    {
        "title": "Menções de erro no PR devem referenciar issues do Sentry",
        "rule": "Se `pr_description` ou `pr_title` mencionam correção de erro, exceção, crash ou problema de produção, deve referenciar uma issue correspondente do Sentry. Siga estes passos: (1) Extraia a mensagem de erro exata, tipo de exceção ou descrição do erro de `pr_description` ou `pr_title`. (2) Use a ferramenta @mcp<sentry|search_events> com uma consulta em linguagem natural baseada na mensagem de erro extraída. Busque eventos dos últimos 30 dias. Inclua caminhos de arquivos mencionados no PR (de `pr_files_diff`) na consulta de busca para encontrar eventos onde stack.filename corresponde aos arquivos alterados. Inclua o ID da issue nos resultados da consulta. (3) Use a ferramenta @mcp<sentry|get_issue_details> com o ID da issue encontrado nos eventos de busca para recuperar detalhes específicos da issue incluindo frequência de erro, usuários afetados, stack traces e ocorrências recentes. (4) Se você tiver informações relevantes dos resultados das ferramentas do Sentry, crie uma sugestão específica para a situação mostrando: o ID da issue do Sentry, a URL da issue, quaisquer problemas encontrados (frequência de erro, impacto no usuário) e exija que essas informações sejam adicionadas à descrição do PR. A descrição do PR deve incluir o ID da issue do Sentry ou URL.",
        "why_is_this_important": "Vincular correções de erro a issues do Sentry fornece contexto de produção, ajuda a verificar que a correção aborda o erro real de produção, permite rastreamento de taxas de resolução de erro e garante que as correções sejam baseadas em dados reais de produção em vez de suposições.",
        "severity": "High",
        "language": "",
        "uuid": "",
        "buckets": [
            "error-handling",
            "observability-logging",
            "pr-hygiene"
        ],
        "scope": "pull-request"
    },
    {
        "title": "PRs devem seguir template de descrição organizacional",
        "rule": "PRs devem seguir o template de descrição de PR organizacional definido no repositório. Siga estes passos: (1) Use a ferramenta @mcp<kodus|kodus_get_repository_files> para localizar arquivos de template de PR. Busque por locais comuns de template: '.github/PULL_REQUEST_TEMPLATE.md', 'docs/pr-template.md', '.github/pull_request_template.md', ou '**/*template*.md'. (2) Use a ferramenta @mcp<kodus|kodus_get_repository_content> para recuperar o conteúdo do arquivo de template. Extraia as seções obrigatórias do template (ex: Motivation, Approach, Testing, Risk Assessment, Description, Checklist). (3) Compare `pr_description` com a estrutura do template: Verifique se todas as seções obrigatórias do template estão presentes em `pr_description`. Verifique que cada seção tem conteúdo significativo, não apenas texto placeholder. (4) Se seções estiverem faltando ou incompletas, crie uma sugestão específica listando quais seções do template estão faltando ou incompletas e exija que elas sejam adicionadas à descrição do PR com conteúdo apropriado.",
        "why_is_this_important": "Templates consistentes de PR garantem que todo contexto necessário seja fornecido, aceleram revisão de código, melhoram qualidade da documentação, ajudam revisores a entender mudanças rapidamente e mantêm padrões organizacionais para comunicação de mudanças.",
        "severity": "Low",
        "language": "",
        "uuid": "",
        "buckets": [
            "pr-hygiene",
            "docs-adrs"
        ],
        "scope": "pull-request"
    },
    {
        "title": "Mudanças de schema de banco de dados devem validar migrações",
        "rule": "Quando mudanças de código envolvem modificações de schema de banco de dados, arquivos de migração de banco de dados correspondentes devem ser criados e validados. Siga estes passos: (1) Verifique `pr_files_diff` para mudanças de schema de banco de dados: Procure por arquivos de migração (migrations/, db/migrations/, alembic/versions/, flyway/, liquibase/), arquivos de definição de schema ou arquivos de modelo com mudanças de banco de dados. Identifique novas tabelas, adições/modificações de colunas, mudanças de índices, modificações de constraints ou migrações de dados. (2) Verifique que arquivos de migração existem: Para cada mudança de schema identificada, verifique se um arquivo de migração correspondente existe em `pr_files_diff`. Arquivos de migração devem seguir convenções de nomenclatura (timestamp_description.sql ou formato version_description). (3) Use ferramentas MCP de banco de dados para validar migrações: Para PostgreSQL, use a ferramenta @mcp<postgres|validate_migration> com o conteúdo do arquivo de migração para verificar sintaxe, verificar problemas potenciais e validar scripts de rollback. Para MySQL, use a ferramenta @mcp<mysql|validate_migration>. Para ferramentas genéricas de banco de dados, use a ferramenta @mcp<database|validate_migration>. Use a ferramenta @mcp<database|check_schema> para verificar que a migração está alinhada com o estado atual do schema. (4) Verifique completude da migração: Verifique que as migrações incluem scripts 'up' e 'down' (rollback). Verifique que as migrações são idempotentes e podem ser aplicadas com segurança. (5) Se migrações estiverem faltando ou inválidas, crie uma sugestão específica exigindo arquivos de migração com detalhes sobre quais mudanças de schema precisam de migrações e quais erros de validação foram encontrados.",
        "why_is_this_important": "Migrações de banco de dados sem validação adequada podem causar interrupções de produção, perda de dados, falhas de deployment e inconsistências de schema. Migrações validadas garantem mudanças seguras de banco de dados, permitem rollbacks, mantêm controle de versão de schema e previnem corrupção de banco de dados de produção.",
        "severity": "Critical",
        "language": "",
        "uuid": "",
        "buckets": [
            "database-query-performance",
            "migrations-backward-compat",
            "security-hardening"
        ],
        "scope": "pull-request"
    },
    {
        "title": "Mudanças devem verificar configuração de alertas de monitoramento",
        "rule": "Quando mudanças de código afetam comportamento do sistema, performance, taxas de erro ou introduzem novas funcionalidades, alertas de monitoramento e dashboards correspondentes devem ser verificados ou atualizados. Siga estes passos: (1) Analise `pr_files_diff` e `pr_description` para identificar áreas afetadas: novos endpoints de API, queries de banco de dados modificadas, tratamento de erro alterado, caminhos de código críticos de performance ou novas funcionalidades. (2) Extraia nomes de serviços, caminhos de endpoints, nomes de métricas ou identificadores de funcionalidades das mudanças de código. (3) Use ferramentas MCP de monitoramento para verificar alertas: Para Datadog, use a ferramenta @mcp<datadog|get_alerts> com o nome do serviço ou nome da métrica para verificar se alertas existem para taxa de erro, latência ou throughput relacionados ao código alterado. Para New Relic, use a ferramenta @mcp<newrelic|get_alerts> com nome da aplicação e nomes de políticas de alerta para verificar cobertura. Para Prometheus, use a ferramenta @mcp<prometheus|get_rules> para verificar se regras de alerta existem para métricas relacionadas às mudanças. Para CloudWatch (AWS), use a ferramenta @mcp<cloudwatch|get_alarms> com nomes de métricas e namespace para verificar configuração de alarmes. (4) Se nenhum alerta for encontrado para mudanças críticas (novos endpoints, mudanças de tratamento de erro, modificações de performance), crie uma sugestão específica exigindo configuração de alertas com detalhes sobre quais métricas devem ser monitoradas (taxa de erro, latência, throughput, etc.).",
        "why_is_this_important": "Alertas de monitoramento faltando ou desatualizados impedem detecção precoce de problemas de produção, atrasam resposta a incidentes, dificultam depuração e podem levar a interrupções prolongadas. Monitoramento adequado garante visibilidade da saúde do sistema e permite detecção proativa de problemas.",
        "severity": "Medium",
        "language": "",
        "uuid": "",
        "buckets": [
            "observability-logging",
            "performance-efficiency",
            "maintainability"
        ],
        "scope": "pull-request"
    },
    {
        "title": "Mudanças de dependências devem ser escaneadas para vulnerabilidades",
        "rule": "Quando mudanças de código incluem atualizações de dependências (verifique `pr_files_diff` para package.json, requirements.txt, pom.xml, Gemfile, go.mod, Cargo.toml ou arquivos de dependência similares), as novas dependências devem ser escaneadas para vulnerabilidades conhecidas. Siga estes passos: (1) Identifique quais arquivos de dependência foram modificados em `pr_files_diff`. Extraia a lista de nomes e versões de pacotes adicionados ou atualizados. (2) Use a ferramenta @mcp<snyk|test_project> com o caminho do repositório e tipo de gerenciador de pacotes para escanear vulnerabilidades nas dependências atualizadas. Alternativamente, use a ferramenta @mcp<snyk|get_vulnerabilities> com nomes e versões específicos de pacotes. (3) Revise os resultados de vulnerabilidade: Verifique vulnerabilidades de severidade alta ou crítica (pontuação CVSS >= 7.0). Verifique se vulnerabilidades afetam as versões específicas sendo adicionadas/atualizadas. (4) Se vulnerabilidades forem encontradas, crie uma sugestão específica mostrando: o nome e versão do pacote vulnerável, o ID CVE da vulnerabilidade ou ID Snyk, nível de severidade, faixa de versão afetada e correção recomendada (atualizar para versão segura ou pacote alternativo). Exija que vulnerabilidades altas/críticas sejam resolvidas antes de mesclar. (5) Se estiver usando OWASP Dependency Check, use a ferramenta @mcp<owasp|scan_dependencies> para realizar escaneamento de segurança adicional e cruzar resultados.",
        "why_is_this_important": "Dependências vulneráveis introduzem riscos de segurança que podem ser explorados em produção. Escanear dependências garante que vulnerabilidades conhecidas sejam identificadas e resolvidas antes que o código seja mesclado, prevenindo violações de segurança e problemas de conformidade.",
        "severity": "Critical",
        "language": "",
        "uuid": "",
        "buckets": [
            "security-hardening",
            "dependency-supply-chain"
        ],
        "scope": "pull-request"
    },
    {
        "title": "Vulnerabilidades de segurança devem referenciar resultados de escaneamento de segurança",
        "rule": "Se um PR aborda vulnerabilidades de segurança, corrige problemas de segurança ou modifica código sensível de segurança (verifique `pr_tags` para 'security', `pr_files_diff` para arquivos relacionados a segurança ou `pr_description` para palavras-chave de segurança), deve referenciar resultados de ferramentas de escaneamento de segurança. Siga estes passos: (1) Identifique mudanças relacionadas a segurança: Verifique se `pr_tags` contém 'security', se arquivos em `pr_files_diff` estão em security/ ou contêm lógica de autenticação/autorização, ou se `pr_description` menciona correções de segurança. (2) Use ferramentas MCP de escaneamento de segurança: Para Snyk, use a ferramenta @mcp<snyk|test_project> para escanear o repositório para vulnerabilidades. Para OWASP Dependency Check, use a ferramenta @mcp<owasp|scan_dependencies> para escanear dependências. Para security hotspots do SonarQube, use a ferramenta @mcp<sonarqube|get_hotspots> para verificar problemas de segurança. (3) Extraia informações de vulnerabilidade: Obtenha IDs CVE, níveis de severidade, componentes afetados e recomendações de remediação dos resultados do escaneamento. (4) Verifique que `pr_description` referencia os resultados do escaneamento de segurança: Verifique se menciona o ID CVE, ID da issue Snyk/OWASP ou fornece um link para o relatório de escaneamento de segurança. (5) Se correções de segurança estiverem presentes mas nenhum resultado de escaneamento for referenciado, crie uma sugestão exigindo que o autor do PR inclua resultados de escaneamento de segurança ou explique por que o escaneamento não foi realizado.",
        "why_is_this_important": "Correções de segurança devem ser rastreáveis a vulnerabilidades específicas para garantir remediação adequada, permitir auditorias de segurança, ajudar a rastrear dívida de segurança e demonstrar conformidade com políticas de segurança.",
        "severity": "High",
        "language": "",
        "uuid": "",
        "buckets": [
            "security-hardening",
            "pr-hygiene"
        ],
        "scope": "pull-request"
    },
    {
        "title": "Tickets do Jira referenciados no PR devem ser validados",
        "rule": "Se um PR referencia um ticket do Jira (verifique `pr_title` e `pr_description` para padrões de ticket do Jira como PROJ-123, ABC-456 ou explícito 'Refs: PROJ-123'), o ticket deve existir e estar acessível. Siga estes passos: (1) Extraia chaves de tickets do Jira de `pr_title` e `pr_description`. Procure por padrões correspondentes ao formato [A-Z]+-[0-9]+. (2) Para cada chave de ticket do Jira encontrada, use a ferramenta @mcp<jira|get_issue> com a chave da issue (ex: 'PROJ-123') para recuperar detalhes do ticket. (3) Verifique informações do ticket: Verifique que o ticket existe, está acessível, tem um status válido e corresponde ao propósito do PR. Se o PR está fechando o ticket, verifique que o ticket está em um estado fechável. (4) Extraia informações relevantes do ticket: Obtenha título do ticket, descrição, status, responsável e informações relacionadas que devem ser refletidas no PR. (5) Se o ticket não for encontrado ou estiver inacessível, crie uma sugestão exigindo uma referência válida de ticket do Jira. Se o ticket existe mas status/detalhes não correspondem ao propósito do PR, crie uma sugestão para atualizar o ticket ou esclarecer o relacionamento. (6) Garanta que `pr_description` inclui a chave do ticket do Jira em um formato claro como 'Refs: PROJ-123' ou 'Closes: PROJ-123'.",
        "why_is_this_important": "Referências válidas de tickets do Jira garantem rastreabilidade entre mudanças de código e requisitos de negócio, permitem gerenciamento adequado de projetos, ajudam a rastrear conclusão de trabalho e mantêm alinhamento entre desenvolvimento e sistemas de rastreamento de projetos.",
        "severity": "Medium",
        "language": "",
        "uuid": "",
        "buckets": [
            "pr-hygiene",
            "maintainability"
        ],
        "scope": "pull-request"
    },
    {
        "title": "Issues do Linear referenciadas no PR devem ser validadas",
        "rule": "Se um PR referencia uma issue do Linear (verifique `pr_title` e `pr_description` para padrões de issue do Linear como LIN-123, ABC-456 ou explícito 'Refs: LIN-123'), a issue deve existir e estar acessível. Siga estes passos: (1) Extraia identificadores de issues do Linear de `pr_title` e `pr_description`. Procure por padrões correspondentes ao formato de issue do Linear ou menções explícitas. (2) Para cada identificador de issue do Linear encontrado, use a ferramenta @mcp<linear|get_issue> com o identificador da issue para recuperar detalhes da issue. (3) Verifique informações da issue: Verifique que a issue existe, está acessível, tem um estado válido e corresponde ao propósito do PR. Se o PR está completando a issue, verifique que a issue está em um estado completável. (4) Extraia informações relevantes da issue: Obtenha título da issue, descrição, estado, responsável e informações relacionadas de ciclo/projeto que devem ser refletidas no PR. (5) Se a issue não for encontrada ou estiver inacessível, crie uma sugestão exigindo uma referência válida de issue do Linear. Se a issue existe mas estado/detalhes não correspondem ao propósito do PR, crie uma sugestão para atualizar a issue ou esclarecer o relacionamento. (6) Garanta que `pr_description` inclui o identificador da issue do Linear em um formato claro como 'Refs: LIN-123' ou 'Closes: LIN-123'.",
        "why_is_this_important": "Referências válidas de issues do Linear garantem rastreabilidade entre mudanças de código e requisitos de produto, permitem rastreamento adequado de projetos, ajudam equipes a entender contexto e mantêm alinhamento entre desenvolvimento e gerenciamento de produto.",
        "severity": "Medium",
        "language": "",
        "uuid": "",
        "buckets": [
            "pr-hygiene",
            "maintainability"
        ],
        "scope": "pull-request"
    },
    {
        "title": "Mudanças de performance devem verificar métricas de monitoramento",
        "rule": "Quando mudanças de código afetam performance (verifique `pr_description` para palavras-chave de performance, `pr_files_diff` para queries de banco de dados, endpoints de API ou código crítico de performance), métricas de monitoramento correspondentes devem ser verificadas. Siga estes passos: (1) Identifique mudanças relacionadas a performance: Analise `pr_files_diff` para modificações de queries de banco de dados, novos endpoints de API, mudanças de cache ou otimizações de algoritmos. Verifique `pr_description` para menções de melhorias de performance ou otimizações. (2) Extraia identificadores de métricas: Identifique nomes de serviços, caminhos de endpoints, nomes de tabelas de banco de dados ou nomes de funções que devem ter métricas correspondentes. (3) Use ferramentas MCP de monitoramento para verificar se métricas existem: Para Datadog, use a ferramenta @mcp<datadog|get_metrics> com nome do serviço e padrões de nome de métrica (ex: 'api.request.duration', 'db.query.time') para verificar se métricas estão sendo coletadas. Para Prometheus, use a ferramenta @mcp<prometheus|query> com queries PromQL para verificar se métricas existem (ex: 'http_request_duration_seconds', 'database_query_duration'). Para CloudWatch, use a ferramenta @mcp<cloudwatch|get_metrics> com namespace e nome da métrica para verificar coleta de métricas. (4) Se mudanças críticas de performance não tiverem métricas correspondentes, crie uma sugestão exigindo instrumentação de métricas com nomes específicos de métricas que devem ser adicionadas (latência, throughput, taxa de erro, etc.).",
        "why_is_this_important": "Mudanças de performance sem métricas de monitoramento tornam impossível medir o impacto de otimizações, detectar regressões de performance ou validar que melhorias alcançaram seus objetivos. Métricas adequadas permitem otimização de performance baseada em dados.",
        "severity": "High",
        "language": "",
        "uuid": "",
        "buckets": [
            "performance-efficiency",
            "observability-logging"
        ],
        "scope": "pull-request"
    },
    {
        "title": "Logs de produção devem ser verificados para padrões de erro",
        "rule": "Quando mudanças de código modificam tratamento de erro, logging ou tratamento de exceções (verifique `pr_files_diff` para código de tratamento de erro, declarações de logging ou catches de exceção), logs de produção devem ser verificados para padrões de erro relacionados. Siga estes passos: (1) Analise `pr_files_diff` para identificar mudanças de tratamento de erro: Procure por novos tipos de exceção, mensagens de erro, declarações de logging ou lógica de tratamento de erro. Extraia padrões de mensagens de erro, nomes de classes de exceção ou formatos de mensagens de log. (2) Extraia nomes de serviços, nomes de funções ou caminhos de arquivos das mudanças de código para identificar onde erros podem ocorrer. (3) Use ferramentas MCP de logging para buscar logs de produção: Para Datadog, use a ferramenta @mcp<datadog|get_logs> com o nome do serviço e padrões de mensagens de erro para buscar ocorrências recentes de erros similares em logs de produção. Busque logs dos últimos 7 dias. (4) Analise resultados de logs: Verifique se os padrões de erro sendo modificados estão realmente ocorrendo em produção. Verifique frequência de erro, usuários afetados e contexto do erro. (5) Se logs de produção mostrarem erros relacionados mas o PR não os referenciar, crie uma sugestão exigindo que o autor do PR referencie os padrões de erro de produção encontrados nos logs e explique como as mudanças abordam esses erros.",
        "why_is_this_important": "Verificar logs de produção garante que mudanças de tratamento de erro abordem problemas reais de produção, ajuda a validar que correções visam problemas reais, permite melhor compreensão de contexto de erro e previne corrigir erros teóricos enquanto problemas reais persistem.",
        "severity": "Medium",
        "language": "",
        "uuid": "",
        "buckets": [
            "error-handling",
            "observability-logging"
        ],
        "scope": "pull-request"
    },
    {
        "title": "Mudanças de performance devem analisar traces do Sentry",
        "rule": "Quando mudanças de código afetam caminhos críticos de performance (verifique `pr_description` para palavras-chave de performance, `pr_files_diff` para queries de banco de dados, endpoints de API ou otimizações de performance), traces de performance do Sentry devem ser analisados. Siga estes passos: (1) Identifique mudanças relacionadas a performance: Verifique `pr_files_diff` para modificações de queries de banco de dados, novos endpoints de API, mudanças de cache, otimizações de algoritmos ou padrões async/await. Verifique `pr_description` para menções de melhorias de performance, redução de latência ou otimização. (2) Extraia nomes de funções, caminhos de endpoints ou nomes de operações que devem ter traces de performance. (3) Use análise de trace do Sentry: Use a ferramenta @mcp<sentry|get_trace_details> com nomes de transações ou nomes de operações para recuperar traces de performance. Busque traces relacionados aos caminhos de código modificados. Analise duração do trace, breakdown de spans e gargalos de performance. (4) Verifique impacto de performance: Verifique se as mudanças melhoram ou mantêm performance com base em dados de trace. Identifique quaisquer regressões ou melhorias de performance. (5) Se mudanças críticas de performance não tiverem análise de trace correspondente, crie uma sugestão exigindo análise de trace com nomes específicos de transações ou operações que devem ser monitoradas, e exija que métricas de performance sejam incluídas na descrição do PR.",
        "why_is_this_important": "Analisar traces do Sentry fornece dados reais de performance de produção, ajuda a validar otimizações de performance, identifica gargalos de performance e garante que mudanças não introduzam regressões de performance.",
        "severity": "High",
        "language": "",
        "uuid": "",
        "buckets": [
            "performance-efficiency",
            "observability-logging"
        ],
        "scope": "pull-request"
    },
    {
        "title": "Cobertura de testes deve atender threshold mínimo",
        "rule": "Quando mudanças de código adicionam novas funcionalidades ou modificam funcionalidade existente (verifique `pr_files_diff` para novas funções, classes ou lógica modificada), cobertura de testes deve ser verificada para atender thresholds mínimos. Siga estes passos: (1) Identifique mudanças de código: Analise `pr_files_diff` para identificar novas funções, classes, métodos ou lógica modificada que devem ter cobertura de testes. Extraia caminhos de arquivos e nomes de funções/classes. (2) Use ferramentas MCP de cobertura: Para SonarQube, use a ferramenta @mcp<sonarqube|get_coverage> com o caminho do arquivo ou nome do componente para recuperar métricas de cobertura de testes atuais. Verifique cobertura de linhas, cobertura de branches e porcentagens de cobertura de funções. (3) Verifique thresholds de cobertura: Verifique se o código modificado ou novo atende thresholds mínimos de cobertura (tipicamente 80% de cobertura de linhas, 70% de cobertura de branches). Verifique que código novo tem arquivos de teste correspondentes. (4) Se cobertura estiver abaixo dos thresholds ou código novo faltar testes, crie uma sugestão específica exigindo cobertura de testes com detalhes sobre quais funções/arquivos precisam de testes e qual porcentagem de cobertura deve ser alcançada. Exija que arquivos de teste sejam adicionados ou atualizados antes de mesclar.",
        "why_is_this_important": "Cobertura adequada de testes garante confiabilidade do código, captura regressões cedo, permite refatoração segura e mantém padrões de qualidade de código. Baixa cobertura aumenta o risco de bugs chegarem à produção.",
        "severity": "High",
        "language": "",
        "uuid": "",
        "buckets": [
            "testing-quality",
            "maintainability"
        ],
        "scope": "pull-request"
    },
    {
        "title": "Licenças de dependências devem ser validadas",
        "rule": "Quando mudanças de código incluem novas dependências (verifique `pr_files_diff` para package.json, requirements.txt, pom.xml, Gemfile, go.mod, Cargo.toml ou arquivos de dependência similares), licenças de dependências devem ser validadas para conformidade. Siga estes passos: (1) Identifique novas dependências: Verifique `pr_files_diff` para modificações de arquivos de dependência. Extraia a lista de nomes e versões de pacotes recém-adicionados. (2) Use ferramentas MCP de validação de licença: Use a ferramenta @mcp<snyk|get_licenses> com os nomes dos pacotes para recuperar informações de licença para cada dependência. Verifique tipos de licença (MIT, Apache, GPL, proprietária, etc.) e compatibilidade de licença. (3) Verifique conformidade de licença: Verifique se licenças são compatíveis com a política de licenciamento do seu projeto. Identifique quaisquer licenças GPL, AGPL ou outras licenças copyleft que possam exigir tratamento especial. Verifique que licenças proprietárias são aceitáveis. (4) Se dependências tiverem licenças incompatíveis ou problemáticas, crie uma sugestão específica listando cada dependência com seu tipo de licença, explicando por que é problemática, e exigindo: substituição por alternativa compatível, ou documentação de por que a licença é aceitável com aprovação legal.",
        "why_is_this_important": "Conformidade de licença previne problemas legais, garante compatibilidade com licenciamento do projeto, evita contaminação de licença copyleft e mantém proteção de propriedade intelectual. Licenças não conformes podem forçar código proprietário a ser open-source.",
        "severity": "Critical",
        "language": "",
        "uuid": "",
        "buckets": [
            "security-hardening",
            "dependency-supply-chain"
        ],
        "scope": "pull-request"
    },
    {
        "title": "Métricas de qualidade de código devem atender padrões do SonarQube",
        "rule": "Quando mudanças de código são feitas (verifique `pr_files_diff` para quaisquer modificações de código), métricas de qualidade de código devem ser verificadas contra padrões do SonarQube. Siga estes passos: (1) Identifique arquivos modificados: Extraia caminhos de arquivos de `pr_files_diff` que contêm mudanças de código. (2) Use métricas de qualidade do SonarQube: Use a ferramenta @mcp<sonarqube|get_measures> com o caminho do arquivo ou nome do componente para recuperar métricas de qualidade incluindo: code smells, bugs, vulnerabilidades, razão de dívida técnica, classificação de manutenibilidade, classificação de confiabilidade e classificação de segurança. (3) Use a ferramenta @mcp<sonarqube|get_issues> para recuperar issues específicas de qualidade para os arquivos modificados, incluindo code smells, bugs e vulnerabilidades. (4) Verifique padrões de qualidade: Verifique que code smells estão dentro de limites aceitáveis, nenhum bug crítico existe, nenhuma vulnerabilidade de alta severidade é introduzida e classificação de manutenibilidade é aceitável (classificação A ou B). (5) Se métricas de qualidade não atenderem padrões, crie uma sugestão específica listando cada issue de qualidade encontrada (code smells, bugs, vulnerabilidades) com sua severidade e localização, e exija que sejam resolvidas antes de mesclar.",
        "why_is_this_important": "Manter padrões de qualidade de código garante código manutenível, reduz dívida técnica, previne bugs e vulnerabilidades e mantém qualidade de código consistente em todo o codebase. Métricas de qualidade ruins indicam código que será difícil de manter.",
        "severity": "Medium",
        "language": "",
        "uuid": "",
        "buckets": [
            "testing-quality",
            "maintainability"
        ],
        "scope": "pull-request"
    },
    {
        "title": "Dashboards de monitoramento devem ser atualizados para novas funcionalidades",
        "rule": "Quando mudanças de código introduzem novas funcionalidades, endpoints ou serviços (verifique `pr_files_diff` para novos endpoints de API, arquivos de serviço ou implementações de funcionalidades), dashboards de monitoramento correspondentes devem ser criados ou atualizados. Siga estes passos: (1) Identifique novas funcionalidades: Analise `pr_files_diff` para identificar novos endpoints de API, classes de serviço, módulos de funcionalidades ou funcionalidade. Extraia nomes de serviços, caminhos de endpoints, identificadores de funcionalidades ou nomes de componentes. (2) Use ferramentas MCP de dashboard: Para Datadog, use a ferramenta @mcp<datadog|get_dashboards> com nome do serviço ou identificador de funcionalidade para verificar se dashboards existem para a nova funcionalidade. Busque dashboards contendo métricas relevantes (taxa de erro, latência, throughput, atividade do usuário). (3) Verifique cobertura de dashboard: Verifique se dashboards incluem métricas para a nova funcionalidade: taxas de erro, latência de requisição, throughput, taxas de sucesso, métricas de engajamento do usuário. Verifique que dashboards estão adequadamente configurados e acessíveis. (4) Se dashboards estiverem faltando ou incompletos para novas funcionalidades, crie uma sugestão específica exigindo criação ou atualização de dashboard com detalhes sobre quais métricas devem ser monitoradas (taxa de erro, latência, throughput, etc.) e quais dashboards precisam ser criados ou atualizados.",
        "why_is_this_important": "Dashboards de monitoramento fornecem visibilidade da saúde de funcionalidades, permitem detecção precoce de problemas, ajudam a rastrear adoção e performance de funcionalidades e suportam tomada de decisão baseada em dados. Dashboards faltando tornam impossível monitorar novas funcionalidades.",
        "severity": "Medium",
        "language": "",
        "uuid": "",
        "buckets": [
            "observability-logging",
            "maintainability"
        ],
        "scope": "pull-request"
    },
    {
        "title": "Incidentes ativos devem ser verificados antes do deployment",
        "rule": "Quando um PR está pronto para mesclar e implantar (verifique `pr_description` para palavras-chave de deployment, status de merge ou prontidão para produção), incidentes ativos devem ser verificados para evitar implantar durante problemas em andamento. Siga estes passos: (1) Identifique prontidão para deployment: Verifique `pr_description` para palavras-chave como 'pronto para implantar', 'merge', 'production' ou status de deployment. (2) Use ferramentas MCP de incidentes: Para Datadog, use a ferramenta @mcp<datadog|get_incidents> para verificar incidentes ativos nos serviços ou sistemas afetados. Verifique severidade do incidente, status (aberto, investigando, resolvido) e serviços afetados. (3) Verifique status do incidente: Verifique se há incidentes ativos (status: aberto ou investigando) que possam ser afetados pelo deployment ou que devem ser resolvidos antes de implantar. Verifique severidade e impacto do incidente. (4) Se incidentes ativos existirem que possam ser afetados pelo deployment, crie uma sugestão exigindo que o incidente seja resolvido ou reconhecido antes do deployment, ou que o deployment seja adiado até que o incidente seja resolvido. Inclua detalhes do incidente (ID, severidade, serviços afetados) na sugestão.",
        "why_is_this_important": "Implantar durante incidentes ativos pode piorar a situação, dificultar depuração, complicar decisões de rollback e aumentar duração do incidente. Verificar incidentes antes do deployment previne problemas compostos.",
        "severity": "High",
        "language": "",
        "uuid": "",
        "buckets": [
            "ci-cd-build-hygiene",
            "observability-logging"
        ],
        "scope": "pull-request"
    },
    {
        "title": "Contexto de projeto do Jira deve ser validado",
        "rule": "Se um PR referencia um ticket do Jira (verifique `pr_title` e `pr_description` para padrões de ticket do Jira como PROJ-123), o contexto do projeto do Jira deve ser validado. Siga estes passos: (1) Extraia chaves de tickets do Jira de `pr_title` e `pr_description`. Procure por padrões correspondentes ao formato [A-Z]+-[0-9]+. Extraia a chave do projeto (ex: 'PROJ' de 'PROJ-123'). (2) Use ferramentas MCP de projeto do Jira: Use a ferramenta @mcp<jira|get_project> com a chave do projeto para recuperar informações do projeto incluindo nome do projeto, chave, descrição e tipo de projeto. (3) Verifique contexto do projeto: Verifique que o projeto está ativo, acessível e relevante para o codebase. Verifique que o tipo de projeto corresponde ao propósito do PR (projeto de desenvolvimento de software, não um projeto de suporte ou documentação). (4) Se múltiplos tickets de projetos diferentes forem referenciados, verifique que todos os projetos são relevantes e acessíveis. (5) Se contexto do projeto não corresponder ou projeto estiver inacessível, crie uma sugestão exigindo referências válidas de projeto ou explicando relevância do projeto. Garanta que `pr_description` inclui contexto do projeto quando múltiplos projetos estão envolvidos.",
        "why_is_this_important": "Validar contexto de projeto do Jira garante que tickets são do projeto correto, previne confusão de referências de projeto erradas, permite rastreamento adequado de projetos e mantém alinhamento entre mudanças de código e gerenciamento de projetos.",
        "severity": "Low",
        "language": "",
        "uuid": "",
        "buckets": [
            "pr-hygiene",
            "maintainability"
        ],
        "scope": "pull-request"
    },
    {
        "title": "Contexto de projeto e ciclo do Linear deve ser validado",
        "rule": "Se um PR referencia uma issue do Linear (verifique `pr_title` e `pr_description` para padrões de issue do Linear), o contexto de projeto e ciclo do Linear deve ser validado. Siga estes passos: (1) Extraia identificadores de issues do Linear de `pr_title` e `pr_description`. (2) Use ferramentas MCP de contexto do Linear: Use a ferramenta @mcp<linear|get_issue> para obter detalhes da issue e extrair informações de projeto e ciclo. Use a ferramenta @mcp<linear|get_project> com o identificador do projeto para recuperar informações do projeto incluindo nome do projeto, descrição e status. Use a ferramenta @mcp<linear|get_cycle> com o identificador do ciclo para recuperar informações do ciclo incluindo nome do ciclo, data de início, data de fim e status. (3) Verifique contexto de projeto e ciclo: Verifique que o projeto está ativo e relevante para o codebase. Verifique que o ciclo é atual ou apropriado para o trabalho sendo feito. Verifique que projeto e ciclo da issue estão alinhados com o propósito do PR. (4) Se contexto de projeto ou ciclo não corresponder ou estiver inacessível, crie uma sugestão exigindo referências válidas de projeto/ciclo ou explicando relevância do contexto. Garanta que `pr_description` inclui informações de projeto e ciclo quando relevante.",
        "why_is_this_important": "Validar contexto de projeto e ciclo do Linear garante que issues são do projeto e ciclo corretos, permite planejamento adequado de sprint, ajuda a rastrear conclusão de trabalho e mantém alinhamento entre mudanças de código e ciclos de gerenciamento de produto.",
        "severity": "Low",
        "language": "",
        "uuid": "",
        "buckets": [
            "pr-hygiene",
            "maintainability"
        ],
        "scope": "pull-request"
    },
    {
        "title": "Declarações console.log não devem ser commitadas em código de produção",
        "rule": "O `fileDiff` não deve conter `console.log`, `console.debug`, `console.info`, `print()`, ou declarações de depuração similares em arquivos que não são arquivos de teste. Siga estes passos: (1) Verifique a variável de contexto `filePath` para determinar se o arquivo é um arquivo de teste. Arquivos de teste tipicamente têm padrões como '.test.', '.spec.', '/test/', '/spec/', '__tests__', ou terminam com 'Test' ou 'Spec'. (2) Analise o `fileDiff` para identificar quaisquer linhas adicionadas contendo `console.log`, `console.debug`, `console.info`, `print()`, `System.out.println`, ou declarações de depuração similares. Procure por linhas começando com '+' que contenham esses padrões. (3) Use ferramentas MCP de qualidade de código para verificar: Para SonarQube, use a ferramenta @mcp<sonarqube|get_issues> com o caminho do arquivo para verificar se há issues de qualidade de código relacionadas a declarações console.log ou anti-padrões de logging. Verifique que padrões de qualidade de código sinalizam uso de console.log em código de produção. (4) Se declarações de depuração forem encontradas em arquivos que não são de teste, crie uma sugestão específica listando cada ocorrência com o número da linha e exigindo que declarações de depuração sejam removidas ou substituídas por logging adequado usando o framework de logging da aplicação (ex: logger.debug(), logger.info()). (5) Se declarações de depuração estiverem em arquivos de teste, elas são aceitáveis e nenhuma ação é necessária.",
        "why_is_this_important": "Declarações console.log em código de produção poluem logs, expõem informações sensíveis, impactam performance e violam melhores práticas de logging. Código de produção deve usar frameworks de logging adequados com níveis de log apropriados.",
        "severity": "Medium",
        "language": "",
        "uuid": "",
        "buckets": [
            "style-conventions",
            "observability-logging"
        ],
        "scope": "file"
    },
    {
        "title": "Secrets hardcoded não devem ser commitados",
        "rule": "O `fileDiff` não deve conter secrets hardcoded, chaves de API, senhas, tokens ou credenciais sensíveis. Siga estes passos: (1) Analise o `fileDiff` para identificar quaisquer linhas adicionadas contendo secrets potenciais. Procure por padrões como: chaves de API (padrões como 'api_key', 'apikey', 'secret', 'token', 'password', 'pwd', 'passwd'), valores hardcoded que parecem secrets (strings aleatórias longas, strings codificadas em base64, tokens JWT), strings de conexão de banco de dados com credenciais, chaves de acesso AWS ou tokens OAuth. (2) Verifique padrões comuns de secrets: Procure por linhas começando com '+' que contenham atribuições como 'password =', 'apiKey =', 'secret =', 'token =', ou padrões similares seguidos de valores hardcoded. (3) Use ferramentas MCP de escaneamento de segurança para verificar: Para SonarQube, use a ferramenta @mcp<sonarqube|get_hotspots> com o caminho do arquivo para verificar hotspots de segurança relacionados a secrets hardcoded. Para Snyk, use a ferramenta @mcp<snyk|test_project> para escanear secrets ou credenciais expostas. Cruze a análise do fileDiff com resultados de escaneamento de segurança. (4) Verifique se valores são secrets reais ou placeholders: Verifique se valores são claramente placeholders (ex: 'YOUR_API_KEY', 'placeholder', 'example.com') que são aceitáveis. (5) Se secrets reais forem encontrados, crie uma sugestão crítica exigindo remoção imediata do secret, explicação de como usar variáveis de ambiente ou sistemas de gerenciamento de secrets, e verificação de que o secret foi rotacionado se foi exposto.",
        "why_is_this_important": "Secrets hardcoded em código criam vulnerabilidades de segurança severas, expõem credenciais em controle de versão, permitem acesso não autorizado, violam melhores práticas de segurança e podem levar a violações de dados. Secrets devem ser armazenados em sistemas seguros de gerenciamento de secrets.",
        "severity": "Critical",
        "language": "",
        "uuid": "",
        "buckets": [
            "security-hardening"
        ],
        "scope": "file"
    },
    {
        "title": "Comentários TODO e FIXME devem referenciar tickets",
        "rule": "O `fileDiff` não deve conter comentários TODO ou FIXME sem referências de tickets. Siga estes passos: (1) Analise o `fileDiff` para identificar quaisquer linhas adicionadas contendo comentários TODO ou FIXME. Procure por padrões como 'TODO:', 'FIXME:', 'HACK:', 'XXX:', ou marcadores similares de dívida técnica. (2) Verifique se comentários TODO/FIXME incluem referências de tickets: Verifique que cada comentário TODO/FIXME inclui uma referência a um sistema de rastreamento de issues (ticket do Jira como PROJ-123, issue do Linear como LIN-123, issue do GitHub como #123, ou ID de ticket explícito). (3) Se comentários TODO/FIXME forem encontrados sem referências de tickets, crie uma sugestão exigindo que cada comentário TODO/FIXME inclua uma referência de ticket no formato como 'TODO(PROJ-123): descrição' ou 'FIXME: descrição (Refs: LIN-456)'. (4) Se comentários TODO/FIXME tiverem referências de tickets, verifique que são válidas usando ferramentas MCP apropriadas (@mcp<jira|get_issue>, @mcp<linear|get_issue>, @mcp<github|get_issue>) para garantir que tickets existem.",
        "why_is_this_important": "Comentários TODO e FIXME sem referências de tickets criam dívida técnica órfã, tornam impossível rastrear e priorizar correções, levam a issues esquecidas e violam melhores práticas de manutenção de código. Referências de tickets permitem rastreamento e priorização adequados.",
        "severity": "Low",
        "language": "",
        "uuid": "",
        "buckets": [
            "maintainability",
            "style-conventions"
        ],
        "scope": "file"
    },
    {
        "title": "Mudanças arquiteturais devem ter documentação ADR",
        "rule": "Quando mudanças de código envolvem decisões arquiteturais, mudanças significativas de design ou escolhas de tecnologia (verifique `pr_files_diff` para novos frameworks, bibliotecas, padrões, mudanças de infraestrutura ou grandes refatorações), um Architecture Decision Record (ADR) deve ser criado ou referenciado. Siga estes passos: (1) Analise `pr_files_diff` e `pr_description` para identificar mudanças arquiteturais: Procure por introduções de novos frameworks ou bibliotecas, mudanças significativas de padrões (ex: mudança de REST para GraphQL, adição de microserviços, mudança de banco de dados, introdução de camada de cache), mudanças de infraestrutura (novos serviços, filas de mensagens, sistemas de eventos) ou refatorações significativas que alteram a arquitetura do sistema. Verifique `pr_description` para palavras-chave como 'arquitetura', 'design', 'padrão', 'framework', 'infraestrutura', 'refatoração' ou 'migração'. (2) Use ferramentas MCP de repositório para localizar diretório ADR: Use a ferramenta @mcp<kodus|kodus_get_repository_files> para buscar diretórios ADR. Locais comuns incluem 'docs/adr/', 'docs/architecture/', 'adr/', 'docs/decisions/' ou 'architecture/decisions/'. Procure por arquivos correspondentes a padrões de nomenclatura ADR como 'ADR-*.md', '*-adr.md' ou formatos numerados como '0001-*.md'. (3) Para cada mudança arquitetural identificada, use a ferramenta @mcp<kodus|kodus_get_repository_content> para verificar se um ADR existe que documenta esta decisão. Busque arquivos ADR por palavras-chave relacionadas à mudança arquitetural (nome do framework, nome do padrão, nome da tecnologia). (4) Verifique completude do ADR: Se um ADR existe, verifique que inclui: contexto (por que a decisão é necessária), decisão (o que foi decidido), consequências (prós e contras, impacto) e status (proposto, aceito, depreciado). (5) Se mudanças arquiteturais forem detectadas mas nenhum ADR existir ou for referenciado, crie uma sugestão específica exigindo que um ADR seja criado com detalhes sobre qual decisão arquitetural precisa ser documentada e onde deve estar localizado. O `pr_description` deve referenciar o número do ADR ou incluir um link para o arquivo ADR.",
        "why_is_this_important": "ADRs documentam decisões arquiteturais, fornecem contexto para desenvolvedores futuros, permitem melhor compreensão da evolução do sistema, previnem discussões repetidas e mantêm conhecimento arquitetural ao longo do tempo. ADRs faltando levam a drift arquitetural e tornam difícil entender por que certas decisões foram tomadas.",
        "severity": "Medium",
        "language": "",
        "uuid": "",
        "buckets": [
            "docs-adrs",
            "maintainability"
        ],
        "scope": "pull-request"
    }
]
