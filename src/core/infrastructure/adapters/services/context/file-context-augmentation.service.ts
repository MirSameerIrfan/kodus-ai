import { Injectable } from '@nestjs/common';
import { PinoLoggerService } from '../logger/pino.service';
import { ContextEvidenceAgentProvider } from '@/core/infrastructure/adapters/services/agent/kodus-flow/contextEvidenceAgent.provider';
import pLimit from 'p-limit';
import {
    CodeReviewConfig,
    FileChange,
} from '@/config/types/general/codeReview.type';
import {
    CodeReviewPipelineContext,
    FileContextAgentResult,
} from '../codeBase/codeReviewPipeline/context/code-review-pipeline.context';
import { ContextMCPDependency } from '@/core/infrastructure/adapters/services/agent/kodus-flow/contextEvidenceAgent.provider';
import type {
    ContextDependency,
    ContextEvidence,
} from '@context-os-core/interfaces';
import { ContextAugmentationsMap } from './code-review-context-pack.service';
import { IKodyRule } from '@/core/domain/kodyRules/interfaces/kodyRules.interface';

@Injectable()
export class FileContextAugmentationService {
    private readonly concurrency = 5;

    constructor(
        private readonly logger: PinoLoggerService,
        private readonly contextEvidenceAgentProvider: ContextEvidenceAgentProvider,
    ) {}

    async augmentFiles(
        files: FileChange[],
        context: CodeReviewPipelineContext,
        mcpDependencies: ContextDependency[],
        kodyRule?: Partial<IKodyRule>,
    ): Promise<Record<string, ContextAugmentationsMap>> {
        if (!files?.length || !mcpDependencies?.length) {
            return {};
        }

        if (!context.organizationAndTeamData) {
            this.logger.warn({
                message:
                    'Missing organizationAndTeamData, skipping file context augmentation',
                context: FileContextAugmentationService.name,
            });
            return {};
        }

        const limit = pLimit(this.concurrency);

        const {
            dependencies: extractedDependencies,
            lookup: dependencyLookup,
        } = this.extractMCPDependencies(mcpDependencies);

        const results = await Promise.all(
            files.map((file) =>
                limit(() =>
                    this.analyzeFile(
                        file,
                        context,
                        extractedDependencies,
                        dependencyLookup,
                        kodyRule,
                    ),
                ),
            ),
        );

        const validResults: FileContextAgentResult[] = [];
        for (const r of results) {
            if (r) {
                validResults.push(r);
            }
        }

        return this.buildAugmentationsByFile(validResults, files);
    }

    private async analyzeFile(
        file: FileChange,
        context: CodeReviewPipelineContext,
        dependencies: ContextMCPDependency[],
        dependencyLookup: Map<string, ContextMCPDependency>,
        kodyRule?: Partial<IKodyRule>,
    ) {
        try {
            const baseOverrides = this.getBasePromptOverrides(context);

            let sandboxEvidences: ContextEvidence[] = [];
            const agentResult = await this.contextEvidenceAgentProvider.execute(
                {
                    organizationAndTeamData: context.organizationAndTeamData,
                    file,
                    dependencies,
                    promptOverrides: baseOverrides,
                    repoContext: this.buildRepositoryContext(context),
                    kodyRule: kodyRule,
                },
            );

            if (!agentResult) {
                this.logger.debug({
                    message: 'Context agent returned null',
                    context: FileContextAugmentationService.name,
                    metadata: {
                        file: file.filename,
                        dependenciesCount: dependencies.length,
                    },
                });
                return null;
            }

            if (agentResult?.actionsLog) {
                this.logger.debug({
                    message: 'Context agent actions log',
                    context: FileContextAugmentationService.name,
                    metadata: {
                        file: file.filename,
                        actionsLog: agentResult.actionsLog,
                    },
                });
            }

            if (agentResult?.evidences?.length) {
                sandboxEvidences = agentResult.evidences;
            }

            if (!sandboxEvidences.length) {
                this.logger.debug({
                    message: 'No evidences generated by agent',
                    context: FileContextAugmentationService.name,
                    metadata: {
                        file: file.filename,
                        actionsLog: agentResult.actionsLog,
                    },
                });
                return null;
            }

            sandboxEvidences = this.attachPathKeyToEvidence(
                sandboxEvidences,
                dependencyLookup,
            );

            return {
                sandboxEvidences,
            };
        } catch (error) {
            this.logger.error({
                message: 'File context augmentation execution failed for file',
                error,
                context: FileContextAugmentationService.name,
                metadata: {
                    file: file.filename,
                    organizationId:
                        context.organizationAndTeamData.organizationId,
                },
            });
            return null;
        }
    }

    private buildAugmentationsByFile(
        results: Array<FileContextAgentResult | null>,
        files: FileChange[],
    ): Record<string, ContextAugmentationsMap> {
        const augmentationsMap: Record<string, ContextAugmentationsMap> = {};
        results.forEach((result, index) => {
            const file = files[index];
            if (!file || !result?.sandboxEvidences?.length) {
                return;
            }

            const fileAugmentations = this.buildAugmentationsForFile(result);
            if (Object.keys(fileAugmentations).length > 0) {
                augmentationsMap[file.filename] = fileAugmentations;
            }
        });
        return augmentationsMap;
    }

    private buildAugmentationsForFile(
        result: FileContextAgentResult,
    ): ContextAugmentationsMap {
        const map: ContextAugmentationsMap = {};

        if (!result?.sandboxEvidences?.length) {
            return map;
        }

        for (const evidence of result.sandboxEvidences) {
            if (
                (evidence.metadata as Record<string, unknown>)
                    ?.executionStatus !== 'success'
            ) {
                continue;
            }

            if (evidence.metadata?.hidden || evidence.metadata?.internal) {
                continue;
            }

            const resolvedToolName =
                (evidence as any).toolName ??
                evidence.metadata?.toolName?.toString() ??
                evidence.metadata?.tool?.toString();

            const pathKey =
                (evidence.metadata?.pathKey as string | undefined) ??
                this.resolvePathKeyFromMetadata(
                    evidence.metadata as Record<string, unknown> | undefined,
                );

            const rawKey = pathKey ?? 'generation.main';
            const key = rawKey.replace(/^v2PromptOverrides\./, '');

            if (!map[key]) {
                map[key] = {
                    path: key.split('.'),
                    outputs: [],
                };
            }

            map[key].outputs.push({
                provider: evidence.provider ?? 'unknown',
                toolName: resolvedToolName ?? 'unknown',
                success: true,
                output: this.serializeEvidencePayload(evidence.payload),
            });
        }

        return map;
    }

    private serializeEvidencePayload(payload: unknown): string {
        if (payload === null || payload === undefined) {
            return 'No output returned.';
        }
        if (typeof payload === 'string') {
            return payload;
        }

        try {
            return JSON.stringify(payload, null, 2);
        } catch {
            return String(payload ?? '[unserializable payload]');
        }
    }

    private extractMCPDependencies(dependencies?: ContextDependency[]): {
        dependencies: ContextMCPDependency[];
        lookup: Map<string, ContextMCPDependency>;
    } {
        const list: ContextMCPDependency[] = [];
        const lookup = new Map<string, ContextMCPDependency>();

        if (!dependencies?.length) {
            return { dependencies: list, lookup };
        }

        for (const dependency of dependencies) {
            if (!dependency || dependency.type !== 'mcp') {
                continue;
            }

            const provider = this.resolveDependencyProvider(dependency);
            const toolName = this.resolveDependencyTool(dependency);

            if (!provider || !toolName) {
                continue;
            }

            const metadataRecord = (dependency.metadata ?? {}) as Record<
                string,
                unknown
            >;

            const info: ContextMCPDependency = {
                provider,
                toolName,
                path: Array.isArray(dependency.metadata?.path)
                    ? (dependency.metadata?.path as string[])
                    : undefined,
                pathKey:
                    typeof dependency.metadata?.pathKey === 'string'
                        ? (dependency.metadata?.pathKey as string)
                        : undefined,
                requirementId:
                    typeof dependency.metadata?.requirementId === 'string'
                        ? (dependency.metadata?.requirementId as string)
                        : undefined,
                metadata: metadataRecord ?? undefined,
                descriptor: dependency.descriptor,
                schema: this.resolveDependencySchema(dependency),
                requiredArgs: this.resolveDependencyRequiredArgs(dependency),
                description: this.resolveDependencyDescription(dependency),
            };

            list.push(info);
            lookup.set(this.normalizeProviderToolKey(provider, toolName), info);
        }

        return { dependencies: list, lookup };
    }

    private getBasePromptOverrides(
        context: CodeReviewPipelineContext,
    ): CodeReviewConfig['v2PromptOverrides'] | undefined {
        return context.codeReviewConfig?.v2PromptOverrides;
    }

    private buildRepositoryContext(context: CodeReviewPipelineContext): string {
        const lines: string[] = [];
        const repo = context.repository;

        if (repo) {
            const repoName = repo.fullName ?? repo.name ?? repo.id ?? 'unknown';
            lines.push(`- Repository: ${repoName}`);
            lines.push(`- Current branch: ${context.branch ?? 'unknown'}`);
        }

        const pr = context.pullRequest;
        if (pr) {
            if (pr.number !== undefined) {
                lines.push(`- Pull Request #: ${pr.number}`);
            }
            if (pr.title) {
                lines.push(`- Pull Request title: ${pr.title}`);
            }
            if (pr.base?.ref) {
                lines.push(`- Pull Request base branch: ${pr.base.ref}`);
            }
        }

        if (context.organizationAndTeamData?.organizationId) {
            lines.push(
                `- Organization ID: ${context.organizationAndTeamData.organizationId}`,
            );
        }
        if (context.correlationId) {
            lines.push(`- Correlation ID: ${context.correlationId}`);
        }

        return lines.length
            ? lines.join('\n')
            : '- Repository metadata not provided.';
    }

    private normalizeProviderToolKey(
        provider?: string,
        toolName?: string,
    ): string {
        return `${(provider ?? 'default').trim().toLowerCase()}|${(toolName ?? '').trim().toLowerCase()}`;
    }

    private attachPathKeyToEvidence(
        evidences: ContextEvidence[],
        dependencyLookup: Map<string, ContextMCPDependency>,
    ): ContextEvidence[] {
        return evidences.map((evidence) => {
            const metadata = {
                ...(evidence.metadata as Record<string, unknown> | undefined),
            };

            if (!metadata.toolName) {
                metadata.toolName = evidence.toolName ?? metadata.toolName;
            }

            if (!metadata.provider) {
                metadata.provider =
                    evidence.provider ?? metadata.provider ?? undefined;
            }

            if (!metadata.pathKey) {
                const provider = this.resolveEvidenceProvider(evidence);
                const toolName =
                    evidence.toolName ?? (metadata.toolName as string);

                if (provider && toolName) {
                    const dependency = dependencyLookup.get(
                        this.normalizeProviderToolKey(provider, toolName),
                    );

                    if (dependency?.metadata) {
                        if (dependency.metadata.hidden) {
                            metadata.hidden = true;
                        }

                        if (dependency.metadata.internal) {
                            metadata.internal = true;
                        }
                    }

                    if (dependency?.pathKey) {
                        metadata.pathKey = dependency.pathKey;
                    }
                }
            }

            return {
                ...evidence,
                metadata,
            };
        });
    }

    private resolveEvidenceProvider(
        evidence: ContextEvidence,
    ): string | undefined {
        const provider =
            (evidence.metadata?.provider as string | undefined) ??
            evidence.provider;
        return typeof provider === 'string'
            ? provider.trim().toLowerCase()
            : undefined;
    }

    private resolveDependencySchema(dependency: ContextDependency): unknown {
        const metadata = dependency.metadata as
            | Record<string, unknown>
            | undefined;
        if (metadata?.toolInputSchema) {
            return metadata.toolInputSchema;
        }

        if (
            dependency.descriptor &&
            typeof dependency.descriptor === 'object' &&
            (dependency.descriptor as Record<string, unknown>).schema
        ) {
            return (dependency.descriptor as Record<string, unknown>).schema;
        }

        return undefined;
    }

    private resolveDependencyDescription(
        dependency: ContextDependency,
    ): string | undefined {
        const metadata = dependency.metadata as
            | Record<string, unknown>
            | undefined;
        if (typeof metadata?.description === 'string') {
            return metadata.description;
        }

        if (
            dependency.descriptor &&
            typeof dependency.descriptor === 'object' &&
            typeof (dependency.descriptor as Record<string, unknown>)
                .description === 'string'
        ) {
            return (dependency.descriptor as Record<string, unknown>)
                .description as string;
        }

        return undefined;
    }

    private resolveDependencyRequiredArgs(
        dependency: ContextDependency,
    ): string[] | undefined {
        const metadata = dependency.metadata as
            | Record<string, unknown>
            | undefined;
        if (Array.isArray(metadata?.requiredArgs)) {
            return (metadata.requiredArgs as unknown[]).filter(
                (item): item is string => typeof item === 'string',
            );
        }

        return undefined;
    }

    private resolvePathKeyFromMetadata(
        metadata?: Record<string, unknown>,
    ): string | undefined {
        if (!metadata) {
            return undefined;
        }

        if (typeof metadata.pathKey === 'string') {
            return metadata.pathKey;
        }

        const category =
            typeof metadata.category === 'string'
                ? metadata.category.toLowerCase()
                : undefined;

        if (category === 'bug') {
            return 'categories.descriptions.bug';
        }

        if (category === 'performance') {
            return 'categories.descriptions.performance';
        }

        if (category === 'security') {
            return 'categories.descriptions.security';
        }

        return undefined;
    }

    private resolveDependencyProvider(
        dependency: ContextDependency,
    ): string | undefined {
        const metadata = dependency.metadata ?? {};
        if (typeof metadata.provider === 'string') {
            return metadata.provider.trim().toLowerCase();
        }
        if (typeof metadata.mcpId === 'string') {
            return metadata.mcpId.trim().toLowerCase();
        }
        const [provider] = dependency.id.split('|', 2);
        return provider?.trim().toLowerCase();
    }

    private resolveDependencyTool(
        dependency: ContextDependency,
    ): string | undefined {
        const metadata = dependency.metadata ?? {};
        if (typeof metadata.toolName === 'string') {
            return metadata.toolName.trim().toLowerCase();
        }
        if (typeof metadata.tool === 'string') {
            return metadata.tool.trim().toLowerCase();
        }
        const [, toolName] = dependency.id.split('|', 2);
        return toolName?.trim().toLowerCase();
    }
}
